### Category rails

---

 - [Add A Check Constraint To A Table](#add-a-check-constraint-to-a-table)
 - [Add A Foreign Key Reference To A Table](#add-a-foreign-key-reference-to-a-table)
 - [Add A Reference Column With An Index](#add-a-reference-column-with-an-index)
 - [Add ActiveRecord Error Not Tied To Any Attribute](#add-activerecord-error-not-tied-to-any-attribute)
 - [Add React With Webpacker To A New Rails App](#add-react-with-webpacker-to-a-new-rails-app)
 - [Add timestamptz Columns With The Migration DSL](#add-timestamptz-columns-with-the-migration-dsl)
 - [Access Secrets In A Rails 5.2 App](#access-secrets-in-a-rails-5.2-app)
 - [ActiveRecord Query For This Or That](#activerecord-query-for-this-or-that)
 - [Advance The Date](#advance-the-date)
 - [Allow List Params Anywhere With Strong Params](#allow-list-params-anywhere-with-strong-params)
 - [All or Nothing Database Transactions](#all-or-nothing-database-transactions)
 - [Assert Two Arrays Have The Same Items With RSpec](#assert-two-arrays-have-the-same-items-with-rspec)
 - [Attach A File With Capybara](#attach-a-file-with-capybara)
 - [Attribute Getter without the Recursion](#attribute-getter-without-the-recursion)
 - [Attribute Was](#attribute-was)
 - [Autosave False On ActiveRecord Associations](#autosave-false-on-activerecord-associations)
 - [Bind Parameters To ActiveRecord SQL Query](#bind-parameters-to-activerecord-sql-query)
 - [Build A Hash Of Model Attributes](#build-a-hash-of-model-attributes)
 - [Capture Development Emails With Mailhog](#capture-development-emails-with-mailhog)
 - [Capybara Page Status Code](#capybara-page-status-code)
 - [Cast Common Boolean-Like Values To Booleans](#cast-common-boolean-like-values-to-booleans)
 - [Change The Nullability Of A Column](#change-the-nullability-of-a-column)
 - [Change The Time Zone Offset Of A DateTime Object](#change-the-time-zone-offset-of-a-datetime-object)
 - [Check If ActiveRecord Update Fails](#check-if-activerecord-update-fails)
 - [Check If Any Records Have A Null Value](#check-if-any-records-have-a-null-value)
 - [Check Specific Attributes On ActiveRecord Array](#check-specific-attributes-on-activerecord-array)
 - [Code Statistics For An Application](#code-statistics-for-an-application)
 - [Columns With Default Values Are Nil On Create](#columns-with-default-values-are-nil-on-create)
 - [Comparing DateTimes Down To Second Precision](#comparing-datetimes-down-to-second-precision)
 - [Conditional Class Selectors in Haml](#conditional-class-selectors-in-haml)
 - [Convert A Symbol To A Constant](#convert-a-symbol-to-a-constant)
 - [Count The Number Of Records By Attribute](#count-the-number-of-records-by-attribute)
 - [Create A Custom Named References Column](#create-a-custom-named-references-column)
 - [Create A Join Table With The Migration DSL](#create-a-join-table-with-the-migration-dsl)
 - [Creating Records of Has_One Associations](#creating-records-of-has_one-associations)
 - [Custom Validation Message](#custom-validation-message)
 - [Customize Paths And Helpers For Devise Routes](#customize-paths-and-helpers-for-devise-routes)
 - [Customize The Path Of A Resource Route](#customize-the-path-of-a-resource-route)
 - [Delete Paranoid Records](#delete-paranoid-records)
 - [Demodulize A Class Name](#demodulize-a-class-name)
 - [Different Ways To Add A Foreign Key Reference](#different-ways-to-add-a-foreign-key-reference)
 - [Disambiguate Where In A Joined Relation](#disambiguate-where-in-a-joined-relation)
 - [Ensure Migrations Use The Latest Schema](#ensure-migrations-use-the-latest-schema)
 - [Find Or Create A Record With FactoryBot](#find-or-create-a-record-with-factorybot)
 - [Find Records With Multiple Associated Records](#find-records-with-multiple-associated-records)
 - [Force All Users To Sign Out](#force-all-users-to-sign-out)
 - [Generating And Executing SQL](#generating-and-executing-sql)
 - [Get ActiveRecord Attribute Directly From Database](#get-activerecord-attribute-directly-from-database)
 - [Get An Array Of Values From The Database](#get-an-array-of-values-from-the-database)
 - [Get An Empty ActiveRecord Relation](#get-an-empty-activerecord-relation)
 - [Get The Column Names For A Model](#get-the-column-names-for-a-model)
 - [Get The Current Time](#get-the-current-time)
 - [Grab A Random Record From The Database](#grab-a-random-record-from-the-database)
 - [Handle Named Arguments In A Rake Task](#handle-named-arguments-in-a-rake-task)
 - [Hash Slicing](#hash-slicing)
 - [Ignore Poltergeist JavaScript Errors](#ignore-poltergeist-javascript-errors)
 - [Include Devise Helpers In Your Controller Tests](#include-devise-helpers-in-your-controller-tests)
 - [Inspect Previous Changes To ActiveRecord Object](#inspect-previous-changes-to-activerecord-object)
 - [Link To The Current Page With Query Params](#link-to-the-current-page-with-query-params)
 - [List All Installable Rails Versions](#list-all-installable-rails-versions)
 - [List The Enqueued Jobs](#list-the-enqueued-jobs)
 - [Load Records In Batches With find_each](#load-records-in-batches-with-find_each)
 - [Log SQL Queries Executed By ActiveRecord](#log-sql-queries-executed-by-activerecord)
 - [Mark A Migration As Irreversible](#mark-a-migration-as-irreversible)
 - [Make ActionMailer Synchronous In Test](#make-actionmailer-synchronous-in-test)
 - [Manually Run A Migrations From Rails Console](#manually-run-a-migrations-from-rails-console)
 - [Mark For Destruction](#mark-for-destruction)
 - [Mask An ActiveRecord Attribute](#mask-an-activerecord-attribute)
 - [Merge A Scope Into An ActiveRecord Query](#merge-a-scope-into-an-activerecord-query)
 - [Migrating Up Down Up](#migrating-up-down-up)
 - [Order Matters For `rescue_from` Blocks](#order-matters-for-`rescue_from`-blocks)
 - [Params Includes Submission Button Info](#params-includes-submission-button-info)
 - [Parse Query Params From A URL](#parse-query-params-from-a-url)
 - [Perform SQL Explain With ActiveRecord](#perform-sql-explain-with-activerecord)
 - [Polymorphic Path Helpers](#polymorphic-path-helpers)
 - [Pretend Generations](#pretend-generations)
 - [Prevent Writes With A Sandboxed Rails Console](#prevent-writes-with-a-sandboxed-rails-console)
 - [Query A Single Value From The Database](#query-a-single-value-from-the-database)
 - [Read In Environment-Specific Config Values](#read-in-environment-specific-config-values)
 - [Read-Only Models](#read-only-models)
 - [Remove The Default Value On A Column](#remove-the-default-value-on-a-column)
 - [Render An Alternative ActionMailer Template](#render-an-alternative-actionmailer-template)
 - [Render The Response Body In Controller Specs](#render-the-response-body-in-controller-specs)
 - [Replace An Index With A Unique Index](#replace-an-index-with-a-unique-index)
 - [Rescue From](#rescue-from)
 - [Rescue From With A Separate Method](#rescue-from-with-a-separate-method)
 - [Retrieve An Object If It Exists](#retrieve-an-object-if-it-exists)
 - [Rollback A Specific Migration Out Of Order](#rollback-a-specific-migration-out-of-order)
 - [Rounding Numbers With Precision](#rounding-numbers-with-precision)
 - [Schedule Sidekiq Jobs Out Into The Future](#schedule-sidekiq-jobs-out-into-the-future)
 - [Secure Passwords With Rails And Bcrypt](#secure-passwords-with-rails-and-bcrypt)
 - [Select A Select By Selector](#select-a-select-by-selector)
 - [Select Value For SQL Counts](#select-value-for-sql-counts)
 - [Serialize With fast_jsonapi In A Rails App](#serialize-with-fast_jsonapi-in-a-rails-app)
 - [Set A Timestamp Field To The Current Time](#set-a-timestamp-field-to-the-current-time)
 - [Set default_url_options For Entire Application](#set-default_url_options-for-entire-application)
 - [Set Schema Search Path](#set-schema-search-path)
 - [Set Statement Timeout For All Postgres Connections](#set-statement-timeout-for-all-postgres-connections)
 - [Set The Default Development Port](#set-the-default-development-port)
 - [Show Pending Migrations](#show-pending-migrations)
 - [Show Rails Models With Pry](#show-rails-models-with-pry)
 - [Show Rails Routes With Pry](#show-rails-routes-with-pry)
 - [Skip Validations When Creating A Record](#skip-validations-when-creating-a-record)
 - [Specify New Attributes For #find_or_create_by](#specify-new-attributes-for-#find_or_create_by)
 - [Temporarily Disable strong_params](#temporarily-disable-strong_params)
 - [Test If An Instance Variable Was Assigned](#test-if-an-instance-variable-was-assigned)
 - [Test If deliver_later Is Called For A Mailer](#test-if-deliver_later-is-called-for-a-mailer)
 - [Test Out URL And Path Helpers In The Console](#test-out-url-and-path-helpers-in-the-console)
 - [Truncate Almost All Tables](#truncate-almost-all-tables)
 - [Update Column Versus Update Attribute](#update-column-versus-update-attribute)
 - [Upgrading Your Manifest For Sprocket's 4](#upgrading-your-manifest-for-sprocket's-4)
 - [Verify And Read A Signed Cookie Value](#verify-and-read-a-signed-cookie-value)
 - [Where Am I In The Partial Iteration?](#where-am-i-in-the-partial-iteration?)
 - [Wipe Out All Precompiled Assets](#wipe-out-all-precompiled-assets)
 - [Write Reversible Migration To Set Default](#write-reversible-migration-to-set-default)
 - [Write Safer Where Clauses With Placeholders](#write-safer-where-clauses-with-placeholders)

---

# Add A Check Constraint To A Table

PostgreSQL allows you to enforce all kinds of rules about the value of a column
or the relationship between two columns. These rules are defined with [_check
constraints_](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-CHECK-CONSTRAINTS).
ActiveRecord's migration DSL does not provide a way for adding check
constraints directly. They can be added by executing a SQL statement in a
migration.

```ruby
class EnsurePageCountIsPositive < ActiveRecord::Migration[5.2]
  def up
    execute <<-SQL
      alter table books
        add constraint ensure_page_count_is_positive
        check (page_count > 0);
    SQL
  end

  def down
    execute <<-SQL
      alter table books
        drop constraint ensure_page_count_is_positive;
    SQL
  end
```

This check constraint ensures that, anytime you add or update a row in the book
column, the value of `page_count` column is always greater than `0`. This is a
nice thing to enforce because it wouldn't make much sense for a book to have,
say, `-10` pages.

Note: these constraints will not appear in your `db/schema.rb` file. If you
want to see what check constraints have been defined across your tables, you
can crack open `psql` to investigate.

# Add A Foreign Key Reference To A Table

Foreign keys are a great way to maintain referential integrity within our data.
We can add reference columns with foreign key constraints using the Rails
migration DSL.

Here is how we include one as part of creating a table:

```ruby
def up
  create_table :books do |t|
    # ... other columns

    t.references :author, index: true, foreign_key: true
  end
end
```

This will add a column, `author_id`, to the `books` table that references the
`authors` table. It will have both a foreign key constraint and an index
applied to it.

Here is how we do the same for an existing table:

```ruby
def up
  add_reference :books, :author, index: true, foreign_key: true
end
```

As of Rails 5, this is a bit verbose as `index: true` happens by default.
Though I'm always in favor of explicitness. If for whatever reason you don't
want an index, you will have to specify `index: false`.

# Add A Reference Column With An Index

Though I prefer to always back my reference columns with a [foreign
key](add-a-foreign-key-reference-to-a-table.md), sometimes you may just want to
add the reference column on its own. Though this could be done manually with
the `add_column` directive, you can be more explicit with `add_reference` --
which allows you to specify whether or not an index is to be added.

```ruby
def up
  add_reference :books, :author, index: true
end
```

This will add `authors_id` and an index to the `books` table.

You can additionally specify the type of the column. This is handy if you are
using `uuid`s for all your primary keys.

```ruby
def up
  add_reference :books, :author, type: :uuid, index: true
end
```

[source](https://nandovieira.com/using-uuid-with-postgresql-and-activerecord)

# Add ActiveRecord Error Not Tied To Any Attribute

Often the [errors on an ActiveRecord
object](https://api.rubyonrails.org/v6.1.3.2/classes/ActiveModel/Errors.html)
are tied to a specific attribute of that object. For instance, when this
validation is violated

```ruby
validates :name, presence: true
```

Then the error will be tied to `:name`.

With the
[`ActiveModel::Errors#add`](https://api.rubyonrails.org/v6.1.3.2/classes/ActiveModel/Errors.html#method-i-add)
method, we can write custom validation logic that ties an error to a specific
attribute.

```ruby
validate :quantity_for_bulk_purchase

def quantity_for_bulk_purchase
  return if purchase_type != :bulk

  if quantity < 12
    errors.add(:quantity, "must be greater than 12 for bulk purchases")
  end
end
```

Errors don't have to be tied to specific attribute. They can be tied to the
object as a whole. This can be better for validations, like the one above, that
involve multiple attributes.

```ruby
validate :quantity_for_bulk_purchase

def quantity_for_bulk_purchase
  return if purchase_type != :bulk

  if quantity < 12
    errors.add(:base, "Quantity must be greater than 12 for bulk purchases")
  end
end
```

By using the `:base` symbol, we are ascribing this error to the object as a
whole.

```
> my_object.errors
#=> #<ActiveModel::Errors:0x00007fccaa5a8740
 @base=
  #<MyObject:0x00007fcc8a5e9238
    ...
    @details={:base=>[{:error=>"Quantity must be greater than 12 for bulk purchases"}]},
    @messages={:base=>["Quantity must be greater than 12 for bulk purchases"]}>

> my_object.errors.full_messages
#=> ["Quantity must be greater than 12 for bulk purchases"]
```

# Add React With Webpacker To A New Rails App

[Webpacker](https://github.com/rails/webpacker) makes it easy to manage
app-like JavaScript in the context of a Rails app. React is a great
candidate for this kind of webpack-powered JavaScript processing pipeline.

To set up a new Rails project with Webpack and React wired up, add the
`--webpack=react` flag:

```bash
$ rails new rails-react-app --webpack=react
```

As part of the generated app, you will get a `app/javascript/packs`
directory with a `hello_react.jsx` file that has a really basic React
component.

[source](https://github.com/rails/webpacker#react)

# Add timestamptz Columns With The Migration DSL

The Rails migration DSL comes with the
[`t.timestamps`](https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html#method-i-timestamps)
method. This allows you to add the `created_at` and `updated_at` timestamp
columns that are standard for most models in Rails apps.

```ruby
create_table :posts do |t|
  t.string :title, null: false
  # ...

  t.timestamps
end
```

With a PostgreSQL database, this will result in a `posts` table that has
`created_at` and `updated_at` columns that are of type `timestamp(6) without
time zone`.

I'd prefer to use timestamp columns that include a time zone offset. PostgreSQL
supports this with its [`timestamptz` (`timestamp with time
zone`)](https://www.postgresql.org/docs/current/datatype-datetime.html) data
type.

We can tell the Rails DSL to generate this type of column by abondoning the
`t.timestamps` method and instead creating custom columns with
[`t.column`](https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html#method-i-column).

```ruby
create_table :posts do |t|
  t.string :title, null: false
  # ...

  t.column :created_at, :timestamptz, null: false
  t.column :updated_at, :timestamptz, null: false
end
```

It is a little less convenient than the `t.timestamps` helper, but it is nice
to know we can have a little more control over the data type.

# Access Secrets In A Rails 5.2 App

For a long time the access chain for getting at secrets in your Rails app
stayed the same. For instance, getting at the `secret_key_base` value looked
something like this:

```ruby
Rails.application.secrets.secret_key_base
```

In the world of Rails 5.2, secrets are no longer secrets. They are now
credentials. This means they are under the `credentials` key instead of the
`secrets` key. Here is how you can access `secret_key_base` now:

```ruby
Rails.application.credentials.secret_key_base
```

[source](https://www.engineyard.com/blog/rails-encrypted-credentials-on-rails-5.2)

# ActiveRecord Query For This Or That

When including multiple `where` clauses on a query, we are adding more
specificity to the resulting `ActiveRecord` relation -- it's like saying we
want records that match this _and_ that. But what about when we want to find
records that match this _or_ that?

This is supported by `ActiveRecord` through the `or` query method.

Let's say we want all books that are either unpublished _or_ are published in
2019.

```ruby
> Book.where(status: 'unpublished').or(Book.where(publication_year: 2019))
=> #<ActiveRecord::Relation [...]>
```

This will generate SQL that includes a `where` clause like the following:

```sql
where (books.status = 'unpublished' or books.publication_year = 2019)
```

See the
[docs](https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-or)
for more details.

# Advance The Date

In Rails land, you can advance a date forward and backward with the
`#advance` method:

```ruby
> Date.today
=> Wed, 31 Aug 2016
> Date.today.advance(days: 1)
=> Thu, 01 Sep 2016
> Date.today.advance(months: 1)
=> Fri, 30 Sep 2016
> Date.today.advance(months: -2)
=> Thu, 30 Jun 2016
```

h/t Dillon Hafer

# Allow List Params Anywhere With Strong Params

The intended use of
[`StrongParams`](https://api.rubyonrails.org/classes/ActionController/StrongParameters.html)
is to prevent unintended params from getting through a controller action during
mass assignment.

This can be put to use other places in your Rails app, such as a service
object, where mass assignment is used to update records.

```ruby
class BookTitleUpdater
  ALLOW_LIST = [:title].freeze

  def self.run(data)
    params = ActionController::Parameters.new(data).permit(*ALLOW_LIST)

    Book.find(data[:id]).update!(params)
  end
end
```

This helps prevent other values from getting inadvertently updated on the `book` record.

```ruby
> ALLOW_LIST = [:title]
> data = { title: "Legacy Code", author_id: 22 }
> params = ActionController::Parameters.new(data).permit(*ALLOW_LIST)
> params.to_h
#=> { title: "Legacy Code" }
```

The `author_id` value is ignored and won't be passed to the `#update` call.

# All or Nothing Database Transactions

When you are updating multiple records in an *all or nothing* scenario, you
can use [Active Record
Transactions](http://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html)
to ensure that either everything is updated or none of it is updated.

For instance, if you are transferring *internet points* from one user's
account to another user's account, you need to be sure that the transfer
balances out. If updating one user is successful, but updating the other
fails, then there will be a discrepancy in the data. A transaction will
ensure that when any part of the update fails the entire transaction is
rolled back (at the database level).

```ruby
User.transaction do
  user1.internet_points += 20
  user2.internet_points -= 20
  user1.save!
  user2.save!
end
```

# Assert Two Arrays Have The Same Items With RSpec

Methods that return arrays of values with inconsistent orderings can be
annoying to test with the `#eq` matcher. To keep your test from fickering,
you'd have to ensure the comparison is the same every time.

```ruby
it "has the correct values" do
  expect(fetch_colors(params).sort).to eq(["blue", "green", "yellow"])
end
```

It'd be better if we could keep our test focused and simple. If sort order
isn't something we care about, then it shouldn't be part of our test. RSpec has
a matcher for this kind of scenario --
[`#match_array`](https://www.rubydoc.info/github/rspec/rspec-expectations/RSpec%2FMatchers:match_array).

```ruby
it "has the correct values" do
  expect(fetch_colors(params)).to match_array(["blue", "green", "yellow"])
end
```

This allows us to ensure that each side of the comparison has the same set
values, irrespective of ordering.

# Attach A File With Capybara

There are two ways to attach a file with
[Capybara](https://github.com/jnicklas/capybara). The more conventional way
is with the
[`attach_file`](http://www.rubydoc.info/github/jnicklas/capybara/Capybara%2FNode%2FActions%3Aattach_file)
method.

Assuming there is a form with a file input similar to the following:

```html
<label for='data-file'>Data File</label>
<input type='file' name='data-file' />
```

```ruby
attach_file('data-file', 'path/to/file.csv')
```

The first argument to `attach_file` is a locator which refers to the `name`
attribute on the `input` tag.

If for some reason there is no `name` attribute on the `input` tag, the file
can be attached with a standard `find` and `set`.

```ruby
find('form input[type="file"]').set('path/to/file.csv')
```

# Attribute Getter without the Recursion

You may find yourself adding a custom *getter* method for one of the
attributes in a Rails model. It might look something like this:

```ruby
def name
  name || account.name
end
```

This method will fall on its face as it quickly expands the stack
recursively calling itself. Instead, you can tell `ActiveRecord` that you
want the value of that attribute without invoking the getter
Instead, we want to get the value of the attribute without invoking the
model's getter. `ActiveRecord` allows us to do this with the
[`read_attribute`](http://api.rubyonrails.org/classes/ActiveRecord/AttributeMethods/Read.html#method-i-read_attribute)
method. Check it out:

```ruby
def name
  read_attribute(:name) || account.name
end
```

[source](http://stackoverflow.com/questions/21835116/overwrite-getter-activerecord-model-rails)

# Attribute Was

When modifying the attributes of an `ActiveRecord` object, you may want to
know what values the modified attributes used to have. `ActiveRecord` gets
some handy methods from the
[`ActiveModel::Dirty`](http://api.rubyonrails.org/classes/ActiveModel/Dirty.html)
module that allow you to check these values out even if the object's
attributes were changed before you received it (though you are out of luck
once it has been saved). Just add `_was` onto the end of the attribute in
question.

```ruby
>> pokemon.name
=> "Charizard"
>> pokemon.name = "Squirtle"
=> "Squirtle"
>> pokemon.name
=> "Squirtle"
>> pokemon.name_was
=> "Charizard"
>> pokemon.save
   ...
=> true
>> pokemon.name_was == pokemon.name
=> true
```

[source](http://api.rubyonrails.org/classes/ActiveModel/Dirty.html)

# Autosave False On ActiveRecord Associations

A relationship between two ActiveRecord models can be established with a
`has_one` or `has_many` association. This relationship has some
implications. By default, saving a record will also save the associated
records that have since been built. Consider this example of users that have
many posts (`has_many posts`).

```ruby
> u = User.first
#=> #<User ...>
> u.posts
#=> []
> u.posts.build(title: "Some Title", content: "This is a post")
#=> #<Post ...>
> u.save
#=> true
> u.posts(reload: true)
#=> [#<Post ...>]
```

When the user is saved, the associated post that was built for that user
also gets saved to the database.

If the association is instead defined with the `autosave` option set to
false, then saving a record will not cause associated records to also be
saved. The associated records will need to be saved explicitly. Consider the
same example from above, but with `has_many posts, autosave: false`.

```ruby
> u = User.first
#=> #<User ...>
> u.posts
#=> []
> u.posts.build(title: "Some Title", content: "This is a post")
#=> #<Post ...>
> u.save
#=> true
> u.posts(reload: true)
#=> []
```

The post wasn't saved with the user and it wasn't saved explicitly, so it
isn't persisted to the database.

# Bind Parameters To ActiveRecord SQL Query

Many of the connection query methods that come with `ActiveRecord` accept an
optional `binds` parameter. This can be used to safely inject parameters into
the query.

Here's a SQL query we could use with one of these methods:

```ruby
sql = <<-SQL
  select
    coalesce(places.latitude, 41.8781) latitude,
    coalesce(places.longitude, -87.6298) longitude
  from places
  join appointments
    on places.id = apointments.places_id
  where appointments.id = $1
    and status = $2
SQL
```

Notice the `$1` and `$2`, those are what will be bound to the two parameters
included as `binds`.

```ruby
connection = ActiveRecord::Base.connection

binds = [[nil, appt_id], [nil, input_status]]
coords = connection.select_one(sql, nil, binds)

coords
#=> { "latitude": 41.8781, "longitude": -87.6298 }
```

Notice the `binds` is an array of tuples. It's the second value in each tuple
that gets bound the corresponding binding indicator in the sql. The syntax is a
bit awkward since it is a lower-level API, however once you know it, you can
manage.

# Build A Hash Of Model Attributes

Have you ever found yourself creating an `ActiveRecord` object with
[FactoryBot](https://github.com/thoughtbot/factory_bot) with the sole purpose
of turning it into a hash of attributes?

```ruby
> FactoryBot.build(:book).attributes
{ "id"=>nil, "title"=>"Fledgling", "genre"=>"fiction" }
```

FactoryBot has a built-in method for doing this:

```ruby
> FactoryBot.attributes_for(:book)
{ title: "Fledgling", genre: "fiction" }
```

It also accepts any traits for that factory:

```ruby
> FactoryBot.attributes_for(:book, :published)
{
  title: "Fledgling",
  genre: "fiction",
  publication_year: 2005,
  page_count: 362
}
```

This is a handy way of build a base set of attributes when testing an API
endpoint.

[source](https://devhints.io/factory_bot)

# Capture Development Emails With Mailhog

My preferred way to capture and view emails being sent by a Rails app in
development is to use [MailHog](https://github.com/mailhog/MailHog). It runs a
local SMTP server at port `1025` and a barebones email client at port `8025`.

The `mailhog` utility can be installed with `brew`:

```bash
$ brew install mailhog
```

The development `smtp` settings are configured in
`config/environments/development.rb`:

```ruby
  config.action_mailer.delivery_method = :smtp
  config.action_mailer.smtp_settings = {
    address: 'localhost',
    port: 1025,
  }
```

Then start running `mailhog` with its default settings:

```bash
$ mailhog
```

All outgoing email from the development server will be captured and viewable in
both `html` and `text` form at `localhost:8025`.

# Capybara Page Status Code

To quickly determine if a page is rendering as expected or not, you can
check the status code of the page. If your page is rendering successfully,
you'll see something like this:

```ruby
> page.status_code
# => 200
```

If some sort of application authorization logic is causing the page to not
render as normal, you may see something like this:

```ruby
> page.status_code
# => 403
```

# Cast Common Boolean-Like Values To Booleans

Sometimes you have to deal with values that are supposed to represent booleans,
but they aren't actually boolean values (i.e. `"t"` instead of `true`). Rail's
`ActiveModel` has a helper for casting these common boolean-like values to
actual booleans.

```ruby
> ActiveModel::Type::Boolean.new.cast('f')
=> false
> ActiveModel::Type::Boolean.new.cast('t')
=> true
> ActiveModel::Type::Boolean.new.cast('true')
=> true
> ActiveModel::Type::Boolean.new.cast('FALSE')
=> false
> ActiveModel::Type::Boolean.new.cast(0)
=> false
> ActiveModel::Type::Boolean.new.cast(1)
=> true
> ActiveModel::Type::Boolean.new.cast(true)
=> true
> ActiveModel::Type::Boolean.new.cast(false)
=> false
```

This cast method gives you a handy way to handle all thsoe different cases.
This is available as of Rails 5+.

# Change The Nullability Of A Column

Do you have an existing table with a column that is exactly as you want it
except that it needs to be changed to either `null: false` or `null: true`?

One option is to use ActiveRecord's `change_column_null` method in your
migration.

For example to change a nullable column to `null: false`, you'll want a
migration like the following:

```ruby
def change
  change_column_null :posts, :title, false
end
```

Note, if you have existing records with `null` values in the `title` column,
then you'll need to deal with those before migrating.

If you want to make an existing column nullable, change that `false` to
`true`:

```ruby
def change
  change_column_null :posts, :title, true
end
```

# Change The Time Zone Offset Of A DateTime Object

Let's say you have a timestamp string that you parse with
[`DateTime.parse`](https://ruby-doc.org/stdlib-2.6.1/libdoc/date/rdoc/DateTime.html#method-c-parse).

```ruby
> DateTime.parse('2021-02-23T11:59:11')
#=> Tue, 23 Feb 2021 11:59:11 +0000
```

Without the specification of a time zone offset in the timestamp string, it
will be parsed as UTC.

If you want to change it to another time zone, you can alter the `offset`
option of the `DateTime` object. Rails provides the
[`#change`](https://api.rubyonrails.org/classes/DateTime.html#method-i-change)
method for doing this.

```ruby
> DateTime.parse('2021-02-23T11:59:11').change(offset: '-600')
#=> Tue, 23 Feb 2021 11:59:11 -0600
```

By changing the `offset` to `-600`, the `DateTime` now represents a time in
Central Time.

[source](https://stackoverflow.com/a/47861810/535590)

# Check If ActiveRecord Update Fails

There are two ways to update an `ActiveRecord` instance (not to mention
[`assign_attributes`](https://api.rubyonrails.org/classes/ActiveModel/AttributeAssignment.html),
[`update_attribute`](https://api.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-update_attribute),
etc.).

You can call
[`update`](https://api.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-update)
and
[`update!`](https://api.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-update-21).
If the updates would make the record invalid based on the model's validations,
then the update will fail.

You can tell if `update` failed because it will return `false` (instead of
`true`).

```ruby
unless book.update(book_params)
  log_book_update_failed(id: book.id)
end
```

The `update!` version will raise an `ActiveRecord::ActiveRecordError`
exception if the update fails.

```ruby
begin
  book.update!(book_params)
rescue ActiveRecord::ActiveRecordError
  log_book_update_failed(id: book.id)
end
```

# Check If Any Records Have A Null Value

I like to add missing `not null` constraints where appropriate when they are
missing. The [`change_column_null`
method](change-the-nullability-of-a-column.md) is the Rails DSL way of doing
this.

But first, you need to be sure that all databases this will be running against
don't have any `null` values already present for any records. If there are
`null` values present, then the migration will fail.

One way of doing that check is with some SQL and the
[`select_values`](https://api.rubyonrails.org/v6.1.0/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-select_values)
method.

```ruby
ActiveRecord::Base
  .connection
  .select_values("select id from projects where user_id is null")
  .any?
```

This bit of SQL asks for the `id`s of any records in the `projects` table where
a specific column (`user_id`) is explicitly `null`.

If this returns `false`, then you are good to migrate. If this returns `true`,
then you'll have to do some data massaging first.

# Check Specific Attributes On ActiveRecord Array

If you're writing a test against a method that returns a collection of
ActiveRecord results, it can be tedious to check specific values for each.
There are certainly an endless number of ways to approach those assertions.

You can keep your assertion fairly concise by using nested RSpec matchers.
There are two in particular that can help with this kind of check:

```ruby
books = get_books_by("David Sedaris")

expect(books).to match_array(
  [
    have_attributes(
      "title" => "Calypso",
      "publication_year" => "2018",
    ),
    have_attributes(
      "title" => "Theft By Finding",
      "publication_year" => "2017",
    ),
  ],
)
```

The outer part of the assertion is `match_array` which checks that the result
is an array of a certain size with specific elements. On its own we'd have to
spell out all the attributes of each book, including things like `created_at`
and `updated_at`. However, by combining it with `have_attributes` matchers, we
are able to make the assertion over a subset of each record's attributes.

# Code Statistics For An Application

Rails applications and engines provide `stats`, a rake task for reporting
high level code statistics. Running it on a small project of mine generated
the following report:

```
$ rake stats
+----------------------+-------+-------+---------+---------+-----+-------+
| Name                 | Lines |   LOC | Classes | Methods | M/C | LOC/M |
+----------------------+-------+-------+---------+---------+-----+-------+
| Controllers          |   179 |   143 |       4 |      20 |   5 |     5 |
| Helpers              |    18 |    16 |       0 |       2 |   0 |     6 |
| Models               |    30 |    22 |       3 |       2 |   0 |     9 |
| Mailers              |     0 |     0 |       0 |       0 |   0 |     0 |
| Javascripts          |    53 |    35 |       0 |       6 |   0 |     3 |
| Libraries            |     0 |     0 |       0 |       0 |   0 |     0 |
| Controller specs     |    22 |    16 |       0 |       0 |   0 |     0 |
| Decorator specs      |    30 |    22 |       0 |       0 |   0 |     0 |
| Feature specs        |   739 |   382 |       0 |      74 |   0 |     3 |
| Model specs          |    70 |    55 |       0 |       0 |   0 |     0 |
| Cucumber features    |   412 |   293 |       0 |       0 |   0 |     0 |
+----------------------+-------+-------+---------+---------+-----+-------+
| Total                |  1553 |   984 |       7 |     104 |  14 |     7 |
+----------------------+-------+-------+---------+---------+-----+-------+
  Code LOC: 216     Test LOC: 768     Code to Test Ratio: 1:3.6
```

# Columns With Default Values Are Nil On Create

Let's say I have a `MagicLinks` model backed by `magic_links` Postgres table.
Both the `id` and `token` columns are of type `UUID` and have default values of
`gen_random_uuid()`. That means from the Rails-side when I go to create a
`MagicLink` record, I don't have to think about specifying values for `id` or
`token` -- the DB will take care of that.

```ruby
> magic_link = MagicLink.create(expires_at: Time.zone.now, user: User.last)
  User Load (5.9ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" DESC LIMIT $1  [["LIMIT", 1]]
  TRANSACTION (0.1ms)  BEGIN
  MagicLink Create (3.1ms)  INSERT INTO "magic_links" ("user_id", "expires_at", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"
...

> magic_link.id
=> "6c6dddbf-4427-407d-8dc8-eef8cb65d491"
> magic_link.token
=> nil
```

This `create` call is translated into an `insert` SQL statement that includes a
`returning` clause. For `create` it is always `returning "id"`. This means that
the `UUID` value generated in Postgres-land for `id` gets passed back into the
ActiveRecord instance. The `UUID` value generated for `token`,  however, is not
because `token` isn't specified in the `returning` clause.

[source](https://github.com/rails/rails/issues/17605)

# Comparing DateTimes Down To Second Precision

You may have an RSpec test for your Rails codebase that asserts about the
datetime a record gets saved with:

```ruby
two_weeks_ago = 2.weeks.ago

record = Thing.create(two_weeks_ago)

expect(record.some_date_time).to eq(two_weeks_ago)
```

This comparison happens with precision down to the nanosecond. Unfortunately,
depending on your operating system and backing database, you may see
inconsistent results due to variations in precision.

One way to deal with this, if you only care about precision down to the second,
is to modify the expecationa little with the [`be_within`
matcher](https://relishapp.com/rspec/rspec-expectations/docs/built-in-matchers/be-within-matcher).

```ruby
two_weeks_ago = 2.weeks.ago

record = Thing.create(two_weeks_ago)

expect(record.some_date_time).to be_within(1.second).of(two_weeks_ago)
```

The `be_within` matcher can also be used as [a nested
matcher](https://twitter.com/jbrancha/status/1213162124777869319?s=20).

# Conditional Class Selectors in Haml

You can assign a class selector to a tag in HAML like so:

```ruby
%div.active
```

You can conditionally assign a class selector in a concise manner like so:

```ruby
%div{ class: ( "active" if @thing.active? ) }
```

You can do multiple conditional class selectors with array syntax:

```ruby
%div{ class: [ ("active" if @thing.active?), ("highlight" if @thing.important?) ] }
```

[source](http://stackoverflow.com/questions/3453560/append-class-if-condition-is-true-in-haml-with-rails)

# Convert A Symbol To A Constant

If you have a symbol and need to convert it to a constant, perhaps because
of some metaprogramming induced by a polymorphic solution, then you may
start off on an approach like the following. In fact, I've seen a number of
StackOverflow solutions like this.

```ruby
:module.to_s.capitalize.constantize
#=> Module
```

That is great for one-word constant names, but what about multi-word
constants like `OpenStruct`. This approach will not work for the symbol
`:open_struct`. We need a more general solution.

The key is to ditch `#capitalize and instead use another ActiveSupport
method, `#classify`.

```ruby
:open_struct.to_s.classify.constantize
#=> OpenStruct
```

# Count The Number Of Records By Attribute

In [Count How Many Records There Are Of Each
Type](postgres/count-how-many-records-there-are-of-each-type.md), I walked
through how to use SQL (in PostgreSQL) to get a count of how many records there
are with each unique value in a given column. This is something I tend to do
with a `type` or `status` column.

We can ask the same question with Rails, with very little code. It produces a
nearly identical query and the same results.

```ruby
> Book.group(:status).count
#=> { nil => 123, "published" => 611, "draft" => 364, "review" => 239 }
```

We've picked the `Book` model and we want it to group books by their `status`.
Tacking on the `#count` at the end tells it to apply the `count` aggregate. The
result is a hash of each unique value of the specified attribute (`status`)
paired with the count.

# Create A Custom Named References Column

The `t.references` and `add_reference` methods both create a foreign key column
name based on the target table.

For instance,

```ruby
add_reference :guests, :user, foreign_key: true, index: true, null: false
```

would create a `user_id` column on the `guests` table.

At times, you'll need to customize the name of the foreign key column. The
Rails migration DSL supports this with the `foreign_key` option.

Here is an example that shows the syntax for both a new table and an existing
table.

```ruby
class AddInvitedByColumnToUser < ActiveRecord::Migration[6.1]
  def change
    create_table :guests, id: :uuid do |t|
      t.string :email, null: false
      t.timestamps

      t.references :invited_by,
        type: :uuid,
        index: true,
        null: false,
        foreign_key: { to_table: :users }
    end

    add_reference :guests, :signed_up_as,
      type: :uuid,
      index: true,
      null: false,
      foreign_key: { to_table: :users }
  end
end
```

The `t.references` call creates a foreign key column to the `users` table named
`invited_by`. The `add_reference` call adds a `signed_up_as` foreign key column
to `guests` that points to users.

[source](https://stackoverflow.com/a/42056089/535590)

# Create A Join Table With The Migration DSL

The Rails migration DSL comes with a helper for creating a join table between
two other existing tables.

Call `create_join_table` with two arguments, symbols for the names of the two
tables.

```ruby
def change
  create_join_table :tags, :posts
end
```

This will create a table with id references columns to each of the tables. The
`db/schema.rb` addition will look something like this:

```ruby
  create_table "posts_tags", id: false, force: :cascade do |t|
    t.bigint "tag_id", null: false
    t.bigint "post_id", null: false
  end
```

A Rails/ActiveRecord convention that comes into play for the creation of this
table.

1. The name should be the pluralized versions of the two joined table names.
2. The joined table names should show up in the table name in alphabetical
   order.

Notice that despite listing `:tags` before `:posts` it creates a table called
`posts_tags`. The DSL handles that for us.

Some `create_join_table` defaults to be aware of:

- It doesn't generate foreign key constraints.
- It uses `bigint` (or `int`) for the keys (even if those tables use UUIDs).
- The references are named after their respective table names.

# Creating Records of Has_One Associations

When working with a model, say a User, that has a `has_many` association
with another model, say a Post, you can create a new post for a user like
so:

```ruby
u1 = User.first
=> #<User:0x...>
u1.posts.create(title: "Some Title", content: "...")
=> #<Post:0x...>
```

What about with a `has_one` association? Consider a Customer that has a
`has_one` association with an Account. Rails provides this method for you:

```ruby
c1.create_account(account_number: 123, ...)
=> #<Account:0x...>
```

Rails also gives you a similar `build` method:

```ruby
c1.build_account(account_number: 123, ...)
=> #<Account:0x...>
```

# Custom Validation Message

When using Rails validations, a standard error message will be provided
whenever there is a violation. Consider the scenario when there is a
uniqueness validation on the email attribute and it is violated:

```ruby
# User model
validates_uniqueness_of :email

# Users controller
new_user.errors.full_messages
#=> ["Email has already been taken"]
```

Sometimes you don't want the default validation message. The validation
declaration can be given a `message` option to specify an alternate
validation message.

```ruby
# User model
validates_uniqueness_of :email, message: 'is not available'

# Users controller
new_user.errors.full_messages
#=> ["Email is not available"]
```

Keep in mind that `full_messages` will prepend the model name to the front
of the message. You'll want to ensure that the resulting message is
coherent.

# Customize Paths And Helpers For Devise Routes

Wih a default Devise setup (`devise_for :users`), the sign up/in/out routes are
located at `/users/sign_up`, `/users/sign_in`, and `/users/sign_out`. And the
path helpers are `new_user_registration_path`, `new_user_session_path`, and
`destroy_user_session_path`, respectively.

These can be customized in `config/routes.rb` by opening up the `devise_scope
:user` block and re-specifying the routes of interest.

```ruby
Rails.application.routes.draw do
  devise_for :users
  devise_scope :user do
    get 'sign_up', to: 'devise/registrations#new'
    get 'sign_in', to: 'devise/sessions#new'
    delete 'sign_out', to: 'devise/sessions#destroy'
  end
end
```

These three custom routes override the paths and helps I described above like
so:

- `sign_up_path` -> `/sign_up`
- `sign_in_path` -> `/sign_in`
- `sign_out_path` -> `/sign_out`

I find these path helpers easier to work with and I like the UX of
registration/session paths not nested under `/user`.

# Customize The Path Of A Resource Route

The `:path` option allows you to customize the path used by a resource route in
Rails' `config/routes.rb` file. This is handy if you have a multi-word resource
that you would like to use dashes in the path.

For instance

```ruby
resources :audio_books
```

would have paths like `/audio_books` and `/audio_books/:id`.

By specifying the `:path` option

```ruby
resources :audio_books, path: 'audio-books'
```

the paths end up like `/audio-books` and `/audio-books/id`.

[source](https://stackoverflow.com/questions/5334465/routes-with-dash-instead-of-underscore-in-ruby-on-rails)

# Delete Paranoid Records

The [ActsAsParanoid gem](https://github.com/ActsAsParanoid/acts_as_paranoid)
provides soft delete functionality to `ActiveRecord` objects in Rails. You
can enhance a model with its functionality like so:

```ruby
class User < ActiveRecord::Base
  acts_as_paranoid
end
```

This gem hijacks `ActiveRecord`'s standard `destroy` and `destroy!`
functionality. If you call either of these methods, instead of the record
being deleted from the database, it's `deleted_at` column is updated from
`nil` to the current timestamp. Resulting in a _soft deleted_ record.

If you call `destroy` or `destroy!` a second time (i.e. on a record that has
already been soft deleted), it will be actually deleted from the database.
Alternatively, you can call `destroy_fully!` from the beginning to skip the
soft delete.

# Demodulize A Class Name

If you call `.class.name` on an instance of some class, the fully qualified
name will be returned, module names and all. Consider the following example
class:

```ruby
module One
  module Two
    class Three
      ...
    end
  end
end
```

```ruby
> One::Two::Three.new.class.name
#=> "One::Two::Three"
```

If you just want the unqualified class name; modules not included, you can
use the `#demodulize` method provided by `ActiveSupport`.

```ruby
> One::Two::Three.new.class.name.demodulize
#=> "Three"
```

# Different Ways To Add A Foreign Key Reference

A foreign key reference creates a relationship between two tables that is
guaranteed by a foreign key constraint.

This is a minimal example.

```ruby
create_table :books
  t.references :author, foreign_key: true
end
```

The `foreign_key: true` is needed here, otherwise just the reference column is
created without a backing constraint. When `foreign_key` is true, an index will
be created for the column as well.

This is a maximal example.

```ruby
create_table :books
  t.references :author, index: true, foreign_key: true, type: :uuid, null: false
end
```

It is explicit about the foreign key and index. It specifies a `not null`
constraint. It declares the type as `uuid` assuming the `authors` table's
primary key is of type `uuid`.

Here is an example with a custom column name.

```ruby
create_table :books
  t.references :written_by, foreign_key: { to_table: :authors }
end
```

Here is adding a reference to an existing table.

```ruby
def up
  add_reference :books, :author, index: true, foreign_key: true
end
```

There are more combinations of these, but I hope there is enough here to be
able to iterate to a solution that works for you.

# Disambiguate Where In A Joined Relation

When you join two tables using ActiveRecord

```ruby
Post.joins(:author)
```

You get a relation that involves both of the tables. This allows you to
write queries that work off the data in that join.

The primary table in the join is `posts`. Any column references in a
`#where` call will be assumed to be related to `posts`. If you want to
reference a column on the `authors` table, you'll need to provide that
specificity.

The hash syntax for `#where` is a great way to do that:

```ruby
Post.joins(:author).where({ authors: { name: "John Steinbeck" }})
```

You can also use the string syntax:

```ruby
Post.joins(:author).where("authors.name = ?", "John Steinbeck")
```

[source](https://apidock.com/rails/v4.2.7/ActiveRecord/QueryMethods/where)

# Ensure Migrations Use The Latest Schema

Real-world migrations in Rails apps can sometimes involve both schema changes
and data changes. For instance, if you are moving a column from one table to
another, you'll need to add a new column, move some data, and then delete the
old column.

```ruby
# Assume the following are defined:
# GenericAuthor for table 'authors'
# GenericBook for table 'books'

def up
  add_column :books, :genre, :string

  GenericAuthor.find_each do |author|
    book = GenericBook.find_by(author_id: author.id)
    book.update!(genre: author.genre)
  end

  remove_column :authors, :genre
end
```

This migration looks straightforward, but you may find that no data actually
gets transferred to the `genre` column on `books`. This is because as a
performance optimization, Rails has cached the scema. Thus an `ActiveRecord`
modification like `book.update!` will be working off a version of the schema
that doesn't include `genre` as a column.

We can ensure `ActiveRecord` is using the latest column informtion for the
`books` table by calling
[`reset_column_information`](https://api.rubyonrails.org/classes/ActiveRecord/ModelSchema/ClassMethods.html#method-i-reset_column_information).

```ruby
def up
  add_column :books, :genre, :string

  GenericBook.reset_column_information

  GenericAuthor.find_each do |author|
    book = GenericBook.find_by(author_id: author.id)
    book.update!(genre: author.genre)
  end

  remove_column :authors, :genre
end
```

Now the update will work and `genre` will be set on `books`.

# Find Or Create A Record With FactoryBot

I have a bunch of tests throughout my test suite that rely on a particular kind
of unique record. Let's say it is a special admin user.

```ruby
admin = FactoryBot.create(:user, email: 'admin@company.com')
```

If this user has already been created then trying to re-create it with
[FactoryBot](https://github.com/thoughtbot/factory_bot) will result in a unique
email validation error.

Another way to approach this would be to either find or create the admin user.
In some standard Rails code that might look like this:

```ruby
admin =
  User.find_by(email: 'admin@company.com') ||
  FactoryBot.create(:user, email: 'admin@company.com')
```

There is some repetitiveness to this that I'd like to avoid. FactoryBot doesn't
have an equivalent to ActiveRecord's `find_and_create_by`, but we can work
around this.

We can add an `initialize_with` directive to the `User` factory.

```ruby
FactoryBot.define do
  factory :user do
    sequence(:email) { |n| 'user#{n}@example.com' }

    # a bunch of other attributes

    initialize_with { User.find_or_create_by(email: email) }
  end
end
```

With this in place, we can call `FactoryBot.create` with the already existing
_admin_ user and it will look up the record instead of raising a validation
error.

[source](https://stackoverflow.com/a/11799674/535590)

# Find Records With Multiple Associated Records

Relational data often involves a table that has a one-to-many relationship with
another table. For instance, a team can be made up of many members. A question
we may want to ask of that data is, what are the records (`teams`) that are
associated with more than one of this other table (`members`).

With a few SQL features that are supported by ActiveRecord's query syntax, we
can answer that question.

To make it interesting, let's say we are trying to answer the question, "what
are the teams that have multiple _active_ members?"

```ruby
Team
  .joins(:members)
  .where(members: { status: 'active' })
  .having("count(*) >= 2")
  .group("teams.id")
  .count

=> {
  123 => 2,
  345 => 3,
  567 => 2,
  ...
}
```

That final `.count` is going to manifest as a `count(*)` in the `select`
clause. That `count(*)` aggregate combined with the `group("teams.id")` is
going to flatten the results to be unique by team ID. Then the `having` clause
will filter out all teams with a member count less than 2. And before that, the
where will cut down the members to only those that are `active`.

If you just want the IDs, you can tack a `#keys` call onto the end of that
query result.

# Force All Users To Sign Out

If you are using cookie-based authentication and you want to sign out all users
(so that they have to re-authenticate), you need to invalidate all of the
cookies.

Because the cookies live in the client's browser, you cannot simply clear them
like you would with session-based authentication. Instead, you need to replace
the session token used to create all those cookies.

First, get a new token:

```bash
$ bundle exec rake secret
538696c1399ff182486e09980ba915d098b8fb23a3ace42c3eea0ab51b18fdff7895cd620f32b263d10d25c2fdba16647f4d8632e9032eccef7406e1ad9cba09
```

Then, replace the current `secret_key_base` value with that new secret token
[wherever it is
stored](https://api.rubyonrails.org/classes/Rails/Application.html#method-i-secret_key_base)
in the production environment.

[source](https://stackoverflow.com/questions/35190591/rails-4-devise-how-to-log-out-all-users)

# Generating And Executing SQL

Rails' ActiveRecord can easily support 90% of the querying we do against the
tables in our database. However, there is the occasional exceptional query
that is more easily written in SQL -- perhaps that query cannot even be
written with the ActiveRecord DSL. For these instances, we need a way to
generate and execute SQL safely. The
[`sanitize_sql_array`](http://api.rubyonrails.org/classes/ActiveRecord/Sanitization/ClassMethods.html#method-i-sanitize_sql_array)
method is invaluable for this.

First, let's get a connection and some variables that we can use downstream
in our query.

```ruby
> conn = ActiveRecord::Base.connection
=> #<ActiveRecord::ConnectionAdapters::PostgreSQLAdapter ...>
> one, ten = 1, 10
=> [1, 10]
```

Now, we are ready to safely generate our SQL query as a string. We have to
use `send` because it is not publicly available. Generally, this is frowned
upon, but in my opinion it is worth breaking the private interface to ensure
our SQL is sanitized.

```ruby
> sql = ActiveRecord::Base.send(:sanitize_sql_array, ["select generate_series(?, ?);", one, ten])
=> "select generate_series(1, 10);"
```

Lastly, we can execute the query with our connection and inspect the
results.

```ruby
> result = conn.execute(sql)
   (0.4ms)  select generate_series(1, 10);
=> #<PG::Result:0x007facd93128a0 status=PGRES_TUPLES_OK ntuples=10 nfields=1 cmd_tuples=10>
> result.to_a
=> [{"generate_series"=>1},
 {"generate_series"=>2},
 {"generate_series"=>3},
 {"generate_series"=>4},
 {"generate_series"=>5},
 {"generate_series"=>6},
 {"generate_series"=>7},
 {"generate_series"=>8},
 {"generate_series"=>9},
 {"generate_series"=>10}]
```

# Get ActiveRecord Attribute Directly From Database

In Rails, an ActiveRecord model will automatically get methods named after each
column in the backing database table. This can be called to retrieve those
values from the respective columns in the database.

What if you wanted to override and alter one of those values? For example,
ensure the `email` value you're passing around is always fully downcased.

Something like this won't quite work.

```ruby
def email
  email.downcase
end
```

Because the method is named `email`, the `email` reference inside it will call
itself, recursively, until it exceeds the stack.

Instead, you need a way of referencing the email attribute that is stored in
the database.
[`attribute_in_database`](https://api.rubyonrails.org/classes/ActiveRecord/AttributeMethods/Dirty.html#method-i-attribute_in_database)
will do the trick.

```ruby
def email
  attribute_in_database('email').downcase
end
```

That will retrieve the value from the `email` column in the database for this
record, downcase it, and return it. Anyone calling `email` won't notice the
difference.

h/t [Dillon Hafer](https://twitter.com/dillonhafer)

# Get An Array Of Values From The Database

We generally get data from our database through [ActiveRecord
models](https://api.rubyonrails.org/classes/ActiveRecord/Base.html):

```ruby
> Product.where(available: true).pluck(:sku)
[ "efg-1234", "pqr-3455", ... ]
```

If we need to do a more specialized query, we might reach for
[`execute`](https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-execute):

```ruby
> ActiveRecord::Base.connection.execute(<<-SQL)
    select split_part(sku, '-', 1) product_type
      from products
      where available = true;
  SQL
[{ "product_type" => "efg" }, { "product_type" => "pqr" }, ... ]
```

The results are bundled up in a predictable, but verbose array of hashes.

We could trim the result down to just the values using either
[`select_values`](https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-select_values)
or
[`select_rows`](https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-select_rows):

```ruby
> ActiveRecord::Base.connection.select_values(<<-SQL)
    select split_part(sku, '-', 1) product_type
      from products
      where available = true;
  SQL
[ "efg", "pqr", ... ]
```

If the SQL statement is to return more than one row in the result, then you'll
want `select_rows` instead of `select_values`.

# Get An Empty ActiveRecord Relation

When you query for something (with `#where`) and there are no results matching
that query, you get something that looks like an empty array (`[]`), but it's
not quite.

```ruby
> result
[]
> result.class
Book::ActiveRecord_Relation
```

It's an empty [`ActiveRecord`
relation](https://api.rubyonrails.org/classes/ActiveRecord/Relation.html).

You can get an instance of an empty `ActiveRecord` relation without
constructing a _no result_ query.

```ruby
> Book.none
[]
> Book.none.class
Book::ActiveRecord_Relation
```

I can think of a couple scenarios where this would be useful:

- as a default value for a method parameter
- as a test value for a method that expects to have an `ActiveRecord` relation
  passed in

[source](https://stackoverflow.com/questions/4877931/how-to-return-an-empty-activerecord-relation)

# Get The Column Names For A Model

An `ActiveRecord` model is backed by a table in your application's database. We
can get the column names for a backing table with `ActiveRecord`s help using
the `.column_names` method.

```ruby
> Book.column_names
=> ["id", "title", "publication_year", "created_at", "updated_at", "author_id", "genre"]
```

Any `ActiveRecord` model will have access to this class method.

See [the
docs](https://devdocs.io/rails~5.2/activerecord/modelschema/classmethods#method-i-column_names)
for more details.

# Get The Current Time

Working with time and time zones in server development can get complicated.
Time-sensitive code that worked locally can unexpected fail when deployed to a
server in a different time zone. Or users can end up seeing timestamps that
look a few hours off.

To avoid this kinds of mistakes in Rails development, we should avoid using
`Time.now` and instead use `Time.current`.

> Rails saves timestamps to the database in UTC time zone. We should always use
> Time.current for any database queries, so that Rails will translate and
> compare the correct times.

```ruby
> Time.zone
=> #<ActiveSupport::TimeZone:0x00007fccf6b0a548
 @name="UTC",
 @tzinfo=#<TZInfo::DataTimezone: Etc/UTC>,
 @utc_offset=nil>
> Time.now
=> 2021-01-28 19:22:42.312577 -0600
> Time.current
=> Fri, 29 Jan 2021 01:22:45.926181000 UTC +00:00
> Time.zone = 'Eastern Time (US & Canada)'
=> "Eastern Time (US & Canada)"
> Time.now
=> 2021-01-28 19:23:28.255106 -0600
> Time.current
=> Thu, 28 Jan 2021 20:23:32.150545000 EST -05:00
```

My server's default time zone is UTC. `Time.now` gives me my computer's system
time (Central Time). `Time.current` gives me the time in UTC. If I then change
the server's time zone to Eastern Time, `Time.now` still offers up my system
time whereas `Time.current` produces the current time in Easter Time.

[source](https://thoughtbot.com/blog/its-about-time-zones)

# Grab A Random Record From The Database

I recently learned of a clever way to grab a random record for a particular
model from the database. This is handy if you are poking around in the database
to see what some records look like.

Order the records for that table randomly and then grab the first.

```ruby
Event.order('random()').first
```

This grabs a random `Event` record from the `events` table.

Note, however, that for Rails 6+, this approach won't work. Because of some
extra safety measures around executing raw SQL, you'll instead have to write
the above as:

```ruby
Event.order( Arel.sql('random()') ).first
```

This uses
[`Arel.sql`](https://api.rubyonrails.org/classes/Arel.html#method-c-sql) to
mark `'random()'` as a known-safe string of SQL.

Because we are explicitly passing a string that represents a known-safe
function call, this is fine. Take care to not pass any user-generated SQL in a
scenario like this unless you know what you're doing.

[source](https://stackoverflow.com/a/49525874/535590)

# Handle Named Arguments In A Rake Task

There are [a number of
ways](https://www.seancdavis.com/blog/4-ways-to-pass-arguments-to-a-rake-task/)
to pass arguments into a Rake task. The standard approach only allows for
positional arguments. When I need named and optional arguments, my preferred
approach is to use environment variables.

Here is a skimmed down version of a user lookup task. Notice the task
definition itself doesn't include any arguments. Instead, a couple optional
values are extracted from the environment (`ENV`) at the beginngin of the task.

```ruby
desc "An example task with named, optional arguments"
task :lookup_user => :environment do
  user_id = ENV['USER_ID']
  email = ENV['EMAIL']

  if user_id.present?
    user = User.find(user_id)

    if user.blank?
      puts "No user for id ##{user_id}"
    end
  elsif email.present?
    user = User.find_by(email: email)

    if user.blank?
      puts "No user for email #{email}"
    end
  end

  puts "User found" if user.present?
end
```

This task can be invoked in the following ways:

```bash
$ rake lookup_user USER_ID=123
```

```bash
$ rake lookup_user EMAIL="user@example.com"
```

or even with both arguments included, in which case the task has been written
to give precedence to `USER_ID`:

```bash
$ rake lookup_user EMAIL="user@example.com" USER_ID=123
```

# Hash Slicing

Rails' ActiveSupport adds
[`#slice`](http://api.rubyonrails.org/classes/Hash.html#method-i-slice) and
[`#slice!`](http://api.rubyonrails.org/classes/Hash.html#method-i-slice-21)
to the `Hash` class. The interface of these two methods seems a little
inconsistent though.

```ruby
> {a: 1, b: 2, c: 3}.slice(:a)
=> {:a=>1}
```

The `#slice` method returns what is being sliced.

```ruby
> {a: 1, b: 2, c: 3}.slice!(:a)
=> {:b=>2, :c=>3}
```

The `#slice!` method, on the other hand, returns what is being excluded.

# Ignore Poltergeist JavaScript Errors

Poltergeist with PhantomJS (<2.0) does not support JavaScript's `bind()`
method. This means that when executing an integration test that exercises
JavaScript with the `bind()` method, an error will occur. If you cannot
simply upgrade to a version of PhantomJS that supports `bind()`, then what
can you do?

Ignore the error!

This can be achieved by placing the following rescue block in the
appropriate place.

```ruby
rescue Capybara::Poltergeist::JavascriptError
```

Use this in moderation. You want to make sure you don't ignore actual
JavaScript errors.

[source](http://stackoverflow.com/questions/22020680/temporarily-set-js-errors-to-false-in-poltergeist)

# Include Devise Helpers In Your Controller Tests

For past versions of Devise, you could include `DeviseHelpers` as part of
`controller` or `request` type tests to have access to the `sign_in` and
`sign_out` helpers.

```ruby
RSpec.configure do |config|
  config.include Devise::TestHelpers, :type => :controller
end
```

As of [Devise
4.2.0+](https://github.com/heartcombo/devise/blob/master/CHANGELOG.md#420---2016-07-01),
the `Devise::TestHelpers` have been deprecated. The
`Devise::Test::ControllerHelpers` module should instead be included.

```ruby
RSpec.configure do |config|
  config.include Devise::Test::ControllerHelpers, :type => :controller
end
```

[source](https://github.com/heartcombo/devise/blob/98fc5e8e396b66b826528811287ea6680a6d0757/lib/devise/test/controller_helpers.rb#L26)

# Inspect Previous Changes To ActiveRecord Object

If you modify an ActiveRecord object, before saving it, you can inspect changes
with methods like `changed?` and `<attr>_changed?`:

```ruby
book.title = "The Fifth Season"

book.changed? #=> true
book.title_changed? #=> true
book.publication_year_changed? #=> false

book.changes
#=> { "title" => ["Original Title", "The Fifth Season"] }
```

After saving an object, it will no longer be in a _dirty_ state and these
methods will have no _changes_ to return.

If you have a reference to the saved ActiveRecord object, you can look at the
_previous_ changes with methods like `previous_changes` and
`<attr>_previously_changed?`:

```ruby
book.title = "The Fifth Season"
book.save

book.title_previously_changed? #=> true
book.previous_changes
#=> { "title" => ["Original Title", "The Fifth Season"] }
```

[source](https://api.rubyonrails.org/classes/ActiveModel/Dirty.html)

# Link To The Current Page With Query Params

The `link_to` method is an ActionView helper for generating an `a` tag within a
Rails view. There are two arguments that tend to comprise this method: the link
text and a path helper.

```ruby
<%= link_to 'Home', root_path %>
```

The `link_to` method can be used to generate a link to the current page with
query params. You can do this be providing a hash instead of a path helper as
the second argument.

```ruby
<%= link_to "All", {filter: 'all'} %>
<%= link_to "New", {filter: 'new'} %>
<%= link_to "Posted", {filter: 'posted'} %>
```

The hash can contain one or more key-value pairs which will be turned into
query params and appended to the end of the current base path.

If these are part of the `posts` index page, then they will render as:

```html
<a href="/posts?filter=all">All</a>
<a href="/posts?filter=new">New</a>
<a href="/posts?filter=posted">Posted</a>
```

This is a great way to create links for a Rails action that presents different
data based on query params. Often this is an index page where filtering is
needed.

[source](https://gorails.com/episodes/rails-link-to-current-page-with-params)

# List All Installable Rails Versions

_Here's a [screencast](https://www.youtube.com/watch?v=IizkvqGLkhU) in case you
want to watch instead of read._

I [was curious](https://twitter.com/jbrancha/status/1345467867479875584?s=20)
what versions of Rails were remotely available to be installed with `gem`. On
its own, `gem list rails` will show all _locally_ installed gems that
partially match `rails`. That'll include gems like `rspec-rails` and
`sprockets-rails`.

First, the `--exact` flag can be added to narrow down the results to an exact
match of `rails`.

Then, the `--remote` flag can be included to request `gem` look for remote
versions. That is, versions available on the rubygems server.

Lastly, the `--all` flag can be included to fetch all versions instead of only
the latest version.

Putting it all together:

```bash
$ gem list rails --exact --remote --all
rails (6.1.0, 6.0.3.4, 6.0.3.3, ... 0.9.0, 0.8.5, 0.8.0)
```

[source](https://stackoverflow.com/a/9146057/535590)

# List The Enqueued Jobs

Many Rails apps need to delegate work to jobs that can be performed at a
later time. Both unit and integration testing can benefit from asserting
about the jobs that get enqueued as part of certain methods and workflows.
Rails provides a handy helper method for checking out the set of enqueued
jobs at any given time.

The
[`enqueued_jobs`](http://api.rubyonrails.org/classes/ActiveJob/QueueAdapters/TestAdapter.html#method-i-enqueued_jobs)
method will provide a store of all the currently enqueued jobs.

It provides a number of pieces of information about each job. One way to
use the information is like so:

```ruby
describe '#do_thing' do
  it 'enqueues a job to do a thing later' do
    Processor.do_thing(arg1, arg2)
    expect(enqueued_jobs.map { |job| job[:job] }).to match_array([
      LongProcessJob,
      SendEmailsJob
    ])
  end
end
```

To use this in your Rails project, just enable the adapter in your test
configuration file:

```ruby
Rails.application.config.active_job.queue_adapter = :test
```

# Load Records In Batches With find_each

The base enumerable method offered by Ruby is `#each`. If you need to interact
with an array of elements, that's a method you'll reach for at some point.

When working with an `ActiveRecord` collection in Rails, you should use the
[`#find_each`](https://api.rubyonrails.org/v6.1.0/classes/ActiveRecord/Batches.html#method-i-find_each)
method instead of `#each`. That's because under the hood it batches the records
that it will load in 1000 at a time. This is important to keep your server's
resource usage from exploding when requesting a ton of records.

Consider a `users` table that contains 10,000 records that are _active_.

```ruby
User.where(active: true).each do |user|
  # do something
end
```

With `#each`, all 10,000 records will be loaded into memory at once as
`ActiveRecord` objects. That's potentially a lot of load on the server's
available memory. Then imagine the table contains 100,000 or 1,000,000 records.
This can become a big problem.

```ruby
User.where(active: true).find_each do |user|
  # do something
end
```

With `#find_each`, which uses
[`#find_in_batches`](https://api.rubyonrails.org/v6.1.0/classes/ActiveRecord/Batches.html#method-i-find_in_batches)
under the hood, only 1000 `ActiveRecord` objects get loaded into memory at a
time.

If you want to exercise more control over the batching, you can use
`#find_in_batches` directly.

# Log SQL Queries Executed By ActiveRecord

When entering ActiveRecord statements in a Rails console, it can be useful to
see what SQL queries are being executed under the hood.

```ruby
> Book.first
  Book Load (25.6ms)  SELECT  "books".* FROM "books" ORDER BY "books"."id" ASC LIMIT $1  [["LIMIT", 1]]
=> #<Book:0x00007f824ec6ff98
```

Notice the line right after the statement shows the corresponding `select`
query.

If you aren't seeing this line of SQL, then you'll need to turn on logging for
ActiveRecord. For instance, your test environment may not be configured to log
the SQL.

Right in your console, try running the following line:

```ruby
> ActiveRecord::Base.logger = Logger.new(STDOUT)
```

Enter an ActiveRecord statement, you should now be seeing the corresponding SQL
queries.

[source](https://stackoverflow.com/a/2936016/535590)

# Mark A Migration As Irreversible

It is in your best interest to, as much as is possible, write your Rails
migrations in a way that they can be safely and reliably rolledback. You want
your `down` to mirror your `up`, in case anything goes wrong.

This isn't always possible though. There are some migrations, in particular
data migrations, that cannot be undone. Something is being changed or destroyed
in an unrecoverable way. When this is the case, you should, by convention,
raise an `IrreversibleMigration` exception.

```ruby
class DestructiveMigration < ActiveRecord::Migration[5.2]
  def up
    execute "-- some destructive SQL"
  end

  def down
    raise ActiveRecord::IrreversibleMigration
  end
end
```

If anyone ever tries to rollback this migration, they will see the exception.
It will be a signal that some manual work is needed to continue rolling back.

See the
[docs](https://api.rubyonrails.org/classes/ActiveRecord/Migration.html#class-ActiveRecord::Migration-label-Irreversible+transformations)
for more details.

# Make ActionMailer Synchronous In Test

When you set up an `ActionMailer` email, the default configuration is for it
to use `ActiveJob` to send the emails. [As of Rails 5, it will do so
asynchronously.](https://blog.bigbinary.com/2016/03/29/rails-5-changed-default-active-job-adapter-to-async.html).
Depending on your preferences for testing emails, you may prefer `ActiveJob`
to send the emails synchronously. This can be done by changing the
`queue_adapter` back to `:inline` in your `config/environments/test.rb`.

```ruby
config.active_job.queue_adapter = :inline
```

If you also configure the `delivery_method` as `:test`:

```ruby
config.action_mailer.delivery_method = :test
```

then emails will be queued up in `ActionMailer::Base.deliveries` allowing
you to write a test like this:

```ruby
expect(ActionMailer::Base.deliveries.count).to eq(1)
```

Check out [the
docs](https://guides.rubyonrails.org/action_mailer_basics.html) for more on
`ActionMailer`.

[source](https://stackoverflow.com/a/42987726/535590)

# Manually Run A Migrations From Rails Console

A migration can be manually run from the rails console. In 99% of cases you are
going to be better off using the migration CLI that Rails provides (e.g. `rails
db:migrate`, `rails db:rollback`, etc.).

If you are in a hyper-specific scenario where you need to run the `up` or the
`down` of a migration without the migration-table check, then you'll want to
consider this approach.

First, connect to the rails console: `rails c`. Then require your migration
file.

```ruby
> require "./db/migration/20200220181733_some_migration.rb"
#=> true
```

You'll now have access to the `SomeMigration` constant. Create an instance of this and then run either the `up`-side of the migration:

```ruby
> SomeMigration.new.up
#=> ... # a bunch of migration output
```

or the `down`-side of it:

```ruby
> SomeMigration.new.down
#=> ... # a bunch of migration output
```

[source](https://stackoverflow.com/a/754316/535590)

# Mark For Destruction

Do you have some complicated logic or criteria for deleting associated
records? [ActiveRecord's
`#mark_for_destruction`](http://api.rubyonrails.org/classes/ActiveRecord/AutosaveAssociation.html#method-i-mark_for_destruction) may come in handy.

Let's say we have _users_ who author _articles_. We want to delete some of
the user's articles based on some criteria -- those articles that have odd
`id`s.

```ruby
> user = User.first
#=> #<User...>
> user.articles.each { |a| a.mark_for_destruction if a.id.odd? }
#=> [#<Article...>, ...]
> user.articles.find(1).marked_for_destruction?
#=> true
> user.articles.find(2).marked_for_destruction?
#=> false
```

We've marked our articles for destruction and confirmed as much with the
[`#marked_for_destruction?`](http://api.rubyonrails.org/classes/ActiveRecord/AutosaveAssociation.html#method-i-marked_for_destruction-3F) method. Now, to go through with the destruction, we just have to save the parent record -- the user.

```ruby
> user.save
   (0.2ms)  BEGIN
  User Exists (0.8ms)  SELECT  1 AS one FROM "users" WHERE ("users"."email" = 'person1@example.com' AND "users"."id" != 1) LIMIT 1
  SQL (3.0ms)  DELETE FROM "articles" WHERE "articles"."id" = $1  [["id", 1]]
  SQL (0.2ms)  DELETE FROM "articles" WHERE "articles"."id" = $1  [["id", 3]]
   (2.1ms)  COMMIT
=> true
```

Note: the parent record must have `autosave: true` declared on the
association.

```ruby
class User < ActiveRecord::Base
  has_many :articles, autosave: true
end
```

# Mask An ActiveRecord Attribute

Let's say we have a `User` model with backing table that has an `email`
attribute.

If we look up a `User` record, we can grab its email because Rails provides an
accessor to that attribute under the hood.

```ruby
> user.email
'Liz.Lemon@example.com'
```

We can write a custom `#email` method on `User` to mask that attribute. We
could do this for any number of reasons. One might be to always downcase the
email before retrieving it and using it througout app code.

```ruby
class User < ApplicationRecord
  def email
    read_attribute(:email).downcase
  end
end
```

This uses the
[`#read_attribute`](https://api.rubyonrails.org/classes/ActiveRecord/AttributeMethods/Read.html#method-i-read_attribute)
method which retreives the type casted value before hitting the accessor
method. We have to do this, rather than calling `#email` directly, because that
would result in an infinite loop.

```ruby
> user.email
'liz.lemon@example.com'
```

I'd probably handle this email scenario at the DB-layer. Nevertheless, this
demonstrates a technique we can use in a variety of scenarios at the
Rails-layer.

# Merge A Scope Into An ActiveRecord Query

Consider an ActiveRecord model with a scope:

```ruby
class Book < ApplicationRecord
  scope :published, -> { where("books.published_at is not null") }
end
```

Now let's say we are working in another part of the codebase composing a query
that gathers all authors with published books. That might look something like
this:

```ruby
published_authors =
  Authors.joins(:book).where("books.published_at is not null")
```

This will get the job done, but we've now duplicated the same logic in
different parts of the app. We can utilize the existing scope on `Book` using
ActiveRecord's
[`merge`](https://devdocs.io/rails~5.2/activerecord/spawnmethods#method-i-merge)
method.

```ruby
published_authors =
  Authors.joins(:book).merge( Book.published )
```

The `merge` method can be used to incorporate any conditions from other partial
queries -- this means both `where` clauses and `joins` clauses.

[source](http://aokolish.me/blog/2015/05/26/how-to-simplify-active-record-scopes-that-reference-other-tables/)

# Migrating Up Down Up

When writing Rails migrations, it is good to define, when possible, what
should happen when migrating *up* and what should happen when migrating
*down*. You'll then want to check that both the *up* and *down* work. This
can be accomplished using the following one-liner:

```bash
$ rake db:migrate && rake db:migrate:redo
```

The `rake db:migration` does what we would expect applying our new migration
and showing us that our *up* works. The `rake db:migrate:redo` first
performs a rollback, showing us that our *down* works, and then migrates
back up again. We now know that our latest migration works going both
directions.

# Order Matters For `rescue_from` Blocks

In a Rails controller, you can declare any number of [`rescue_from`
blocks](https://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html)
for capturing and responding to execeptions that are raised by your
application.

```ruby
class BooksController < BaseController

  rescue_from ForbiddenAction do |e|
    render json: { error: e.message }.to_json, status: 403
  end

  rescue_from StandardError do |e|
    render json: { error: e.message }.to_json, status: 500
  end

  def index
    # ...

    raise ForbiddenAction, "Which rescue_from is this going to hit?"
  end
end
```

The potential problem with above is the ordering of the two `rescue_from`
blocks. Assume that `ForbiddenAction` is a subclass of the `StandardError`
class -- this is likely the case for exceptions you declare in your app. The
top `rescue_from` will never get hit because everything that subclasses
`StandardError` will be trapped by the bottom `rescue_from`.

These `rescue_from` blocks are applied bottom-up. That means you have to
consider the class hierarchy when structuring your code. In the above code
example, if we flip the two of them around, we will then get what we are
expecting.

# Params Includes Submission Button Info

When a form is submitted for a Rails app, the respective controller action
will have access to a variety of information in the `params` hash. Included
is an entry with the name and value of the button that submitted the form.
By default, Rails will give the name `commit` to a submission button.

```
<%= f.submit %>
# results in:
<input type="submit" name="commit" value="Submit">Submit</input>
```

The corresponding `create` action will have parameters that include that
submission button's info:

```ruby
# in create action
> params['commit']
=> 'Submit'
```

This is useful when you have multiple buttons that submit the same form, but
should have slightly different results in the corresponding action.
Differentiating becomes easy when you can easily check which was used to
submit the form. No javascript required.

# Parse Query Params From A URL

For all of the conveniences that Ruby and Rails affords a developer through
their expansive APIs, I am always surprised that it is hard to inspect the
query params in a URL.

Let's take a URL and walk through the steps it takes to pull out the value of a
query param.

Here's a URL:

```ruby
url = "https://example.com?taco=bell&taco_count=3"
=> "https://example.com?taco=bell&taco_count=3"
```

Let's parse the URL with `URI`:

```ruby
> URI(url)
=> #<URI::HTTPS https://example.com?taco=bell&taco_count=3>
```

Then grab the `query` part of that `URI`:

```ruby
> URI(url).query
=> "taco=bell&taco_count=3"
```

This is an unparsed string. In a Rails context, this can be parsed with
`Rack::Utils.parse_nested_query`:

```ruby
> query_params = Rack::Utils.parse_nested_query(URI(url).query)
=> {"taco"=>"bell", "taco_count"=>"3"}
```

And now we have a hash of values we can inspect:

```ruby
> query_params["taco_count"]
=> "3"
```

Be sure to do _string_ and not _symbol_ hash access here.

These steps can be wrapped up into a method:

```ruby
module UrlHelpers
  def query_params(url)
    unparsed_query_params = URI(url).query
    Rack::Utils.parse_nested_query(unparsed_query_params)
  end
end
```

[source](https://stackoverflow.com/a/3218018/535590)

# Perform SQL Explain With ActiveRecord

Want to check out the performance characteristics of some SQL query from
within a Pry session? `ActiveRecord` allows you to perform a SQL `explain`
on any `ActiveRecord::Relation` object. After chaining some Arel functions
together, add an `#explain`.

Here is an example:

```ruby
Recipe.all.joins(:ingredient_amounts).explain
  Recipe Load (0.9ms)  SELECT "recipes".* FROM "recipes" INNER JOIN "ingredient_amounts" ON "ingredient_amounts"."recipe_id" = "recipes"."id"
=> EXPLAIN for: SELECT "recipes".* FROM "recipes" INNER JOIN "ingredient_amounts" ON "ingredient_amounts"."recipe_id" = "recipes"."id"
                                 QUERY PLAN
----------------------------------------------------------------------------
 Hash Join  (cost=1.09..26.43 rows=22 width=148)
   Hash Cond: (ingredient_amounts.recipe_id = recipes.id)
   ->  Seq Scan on ingredient_amounts  (cost=0.00..21.00 rows=1100 width=4)
   ->  Hash  (cost=1.04..1.04 rows=4 width=148)
         ->  Seq Scan on recipes  (cost=0.00..1.04 rows=4 width=148)
(5 rows)
```

[source](https://robots.thoughtbot.com/why-postgres-wont-always-use-an-index)

# Polymorphic Path Helpers

Underlying many of the path helpers that we use day to day when building out
the views in our Rails apps are a set of methods in the
[`ActionDispatch::Routing::PolymorphicRoutes`](http://api.rubyonrails.org/classes/ActionDispatch/Routing/PolymorphicRoutes.html)
module.

The `#polymorphic_path` method given an instance of a model will produce the
relevant show path.

```ruby
> app.polymorphic_path(Article.first)
  Article Load (0.5ms)  SELECT  "articles".* FROM "articles"  ORDER BY "articles"."id" ASC LIMIT 1
=> "/articles/2"
```

Given just the model's constant, it will produce the index path.

```ruby
> app.polymorphic_path(Article)
=> "/articles"
```

Additionally, there are variants with `edit_` and `new_` prefixed for
generating the edit and new paths respectively.

```ruby
> app.edit_polymorphic_path(Article.first)
  Article Load (0.6ms)  SELECT  "articles".* FROM "articles"  ORDER BY "articles"."id" ASC LIMIT 1
=> "/articles/2/edit"
> app.new_polymorphic_path(Article)
=> "/articles/new"
```

# Pretend Generations

To get an idea of what a `rails generate` command is going to to
*generate*, you can do a dry run with the `-p` flag or
the `--pretend` flag. If you run

```
$ rails generate model post -p
```

then you will see the following output

```
    invoke  active_record
    create    db/migrate/20150513132556_create_posts.rb
    create    app/models/post.rb
    invoke    rspec
    create      spec/models/post_spec.rb
    invoke      factory_girl
    create        spec/factories/posts.rb
```

though those files will not have actually been created. You now know
precisely what rails will generate for you.

[source](http://rubyquicktips.com/post/19223887750/pretend-to-generate)

# Prevent Writes With A Sandboxed Rails Console

I often open a `rails console` to play around with some data and make sure I
understand how some models can be instantiated while respecting their
associations. There are plenty of times where I've created some data in the
`development` database that doesn't need to be there. It may even be incomplete
data from a failed experiment.

This data accumlates and clutters up the database.

One way to avoid this is by running the console in a sandboxed mode. Include
the `--sandbox` flag when starting up a session to do this.

```bash
$ rails console --sandbox
Loading development environment in sandbox (Rails 5.2.6)
Any modifications you make will be rolled back on exit
[1] pry(main)>
```

This wraps the session in a transaction so that any writes to the database can
be rolledback afterward.

[source](https://dev.to/citizen428/rails-quick-tips-1-console-sandbox-4k0c)

# Query A Single Value From The Database

In a Rails context, most database interactions tend to happen through the ORM
(e.g. `Book.find("123")`). There is a general purpose escape hatch that lets
you execute a SQL statement directly against the DB -- `execute`. The resulting
value of `execute`, however, tends to be a little clunky to work with.

If you just need a single value from the DB, use the
[`select_value`](https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-select_value)
method.

```ruby
> statement = "select gen_random_uuid()"
> ActiveRecord::Base.connection.select_value(statement)
   (5.0ms)  select gen_random_uuid()
 => "abc2e780-f442-418b-afa3-56f0ccd0a903"
```

This is the cleanest way to get the result of a "single value" query.

If you happen to pass in a query that results in more than one row or column,
it will return the value of the first column from the first row.

# Read In Environment-Specific Config Values

The [`config_for`](https://apidock.com/rails/Rails/Application/config_for)
method allows you to read in a YAML file for the current environment in your
config files. These YAML files need to be located in the `config` directory.

For instance, let's say you have `config/extra_settings.yml`:

```yml
development:
  support_email: support+dev@test.com

production:
  support_email: support@test.com
```

You can read that file in as part of your `application.rb` config setup:

```ruby
# config/application.rb
module MyApp
  class Application < Rails::Application
    extra_settings = config_for(:extra_settings)
    set_support_email(extra_settings.fetch(:support_email))
  end
end
```

In `development` this call to `config_for` would return a hash of the values
under `development`. Likewise in `production`.

# Read-Only Models

Are you in the midst of a big refactoring that is phasing out an
`ActiveRecord` model? You may not be ready to wipe it from the project, but
you don't want it accidentally used to create any database records. You
essentially want your model to be read-only until it is time to actually
delete it.

This can be achieved by adding a `readonly?` method to that model that
always returns `true`.

```ruby
def readonly?
  true
end
```

`ActiveRecord`'s underlying persistence methods always check `readonly?`
before creating or updating any records.

[source](http://stackoverflow.com/questions/5641410/is-there-an-easy-way-to-make-a-rails-activerecord-model-read-only)

h/t Josh Davey

# Remove The Default Value On A Column

You have a column on one of your database tables with a default value. You'd
like to remove the default value. Removing the default is the same as
setting it to `nil`. You can do this with the ActiveRecord DSL using the
`change_column_default` method.

```ruby
def change
  change_column_default :users, :age, nil
end
```

See [the
docs](http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_column_default)
for more details.

# Render An Alternative ActionMailer Template

The convention for Rails's ActionMailer is to render the view template that
corresponds to the mailer class's name and the specific action.

For instance, the `welcome_email` method in the `RegistrationMailer` class will
correspond to the `app/views/registration_mailer/welcome_email.html.erb` view.

This convention can be overridden. By passing, the `template_name` and
`template_path` arguments as options to the `mail` method, you can tell the
mailer to render a different template.

```ruby
class RegistrationMailer < ActionMailer::Base
  def welcome_email
    # mail setup ...

    mail(to: @user.email,
        subject: 'Welcome!',
        template_name: 'new_welcome')
  end
end
```

This will look for and use the
`app/views/registration_mailer/new_welcome.html.erb` template.

Also including the `template_path` option will alter the path to the named
template:

```ruby
class RegistrationMailer < ActionMailer::Base
  def welcome_email
    # mail setup ...

    mail(to: @user.email,
        subject: 'Welcome!',
        template_path: 'v2_mailer_templates',
        template_name: 'new_welcome')
  end
end
```

This will look for the `app/views/v2_mailer_templates/new_welcome.html.erb`
template.

[source](https://guides.rubyonrails.org/action_mailer_basics.html#mailer-views)

# Render The Response Body In Controller Specs

Controller specs skip the rendering of views by default. If you want to inspect
some aspect of what is rendered in the HTML body of a response
(`response.body`), you can include the `render_views` directive in that spec.

```ruby
require 'rails_helper'

RSpec.describe DashboardController do
  describe '#index' do
    render_views

    context 'when there is a signed in user' do
      it 'includes their email' do
        user = User.create(email: 'user@example.com')

        sign_in(user)

        get :index

        expect(response.body).to include('user@example.com')
      end
    end
  end
end
```

The `render_views` directive call can go at the top of a spec, and all views
for all tests will be rendered. Or you can place it in the nested contexts only
where it is needed.

View rendering is skipped by default in an effort to keep tests speedy. To not
unnecessarily slow down your test suite, make sure to use it sparingly and only
in tests where you are actually inspecting `response.body`.

# Replace An Index With A Unique Index

Indexes and uniqueness constraints often go together. In fact, in Postgres,
when you create a unique constraint, an index is created under the hood to
support that constraint.

What if you already have an index, but you want to turn it into a unique index?
There is no way to alter or update the index to be unique. Instead, what you'll
want to do is drop the index and then recreate it as a unique index.

Here's how you can do that with the Rails migration DSL:

```ruby
class ReplaceIndexWithUniqueIndex < ActiveRecord::Migration[5.2]
  disable_ddl_transaction!

  def up
    remove_index :users_roles, [:user_id, :role_id]
    add_index :users_roles, [:user_id, :role_id], unique: true, algorithm: :concurrently
  end

  def down
    remove_index :users_roles, [:user_id, :role_id]
    add_index :users_roles, [:user_id, :role_id], algorithm: :concurrently
  end
end
```

This removes the original multi-column index and then adds back in a unique
index that covers the same columns. I added `disable_ddl_transactions!` so that
the new index could be added concurrently.

I've also included a `down` migration that reverses the process in case a
rollback is needed.

# Rescue From

The
[`rescue_from`](http://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html)
method, provided by `ActiveSupport`, is a handy way to provide a catch-all
response to a particular exception in Rails controllers.

For instance, if many of the controllers in your application raise a
`User::NotAuthorized` error for unauthorized requests, the
`ApplicationController` can provide a unified response. This will help dry
up your controllers and prevent any potential inconsistencies.

```ruby
class ApplicationController < ActionController::Base
  rescue_from User::NotAuthorized do |exception|
    # respond with some Not Authorized page
  end

  ...
end
```

# Rescue From With A Separate Method

In an earlier post on [`rescue_from`](rescue_from.md), I showed how you can
write an exception handler with a block argument.

If instead you'd prefer to implement the exception handler as a separate
method, you can do that by passing
[`rescue_from`](http://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html)
a `with` keyword argument. This too will behave as a catch-all for a particular
exception raised in your controller.

Here is what that can look like:

```ruby
class ApplicationController < ActionController::Base
  rescue_from User::NotAuthorized, with: :handle_unauthorized_user

  def index
    # ...
  end

  private

  def handle_unauthorized_user(exception)
    # respond with some Not Authorized page
  end
end
```

If the `User::NotAuthorized` exception bubbles up to the `rescue_from`, then it
will hand that exception off to the `handle_unauthorized_user` method. We can
include whatever logic and monitoring we want here and then render an
appropriate response.

# Retrieve An Object If It Exists

Rails' Active Support provides the `blank?` and `present?` convenience
methods as extensions to many objects. It also extends the Object class by
providing the [`presence`](http://api.rubyonrails.org/classes/Object.html#method-i-presence)
method. This method returns the *receiver* if it is not blank, otherwise
it returns nil.

Instead of doing

```ruby
User.nickname.present? ? User.nickname : User.firstname
```

I can simply do

```ruby
User.nickname.presence || User.firstname
```

# Rollback A Specific Migration Out Of Order

If you want to rollback the latest migration that is `up`, you can use:

```bash
$ rails db:rollback
```

It deals explicitly with the latest `up` migration and nothing else. Even if
you name a specific `VERSION`, it will still just rollback the one latest.

Instead, if you want to target a specific past migration for rollback, you'll
want the `db:migrate:down` command. You'll need to specify the version, which
is the timestamp number in the filename of the migration.

Here is what this looks like for a recent migration I had to rollback.

```bash
$ rails db:migrate:down VERSION=20210302171858
```

[source](https://stackoverflow.com/a/3647820/535590)

# Rounding Numbers With Precision

Ruby's `Float#round` method gets the job done, but doesn't offer much
configurability. If you'd like to finely control how a rounded number will
display, `ActiveSupport::NumberHelper` offers
[`number_to_rounded`](https://api.rubyonrails.org/classes/ActiveSupport/NumberHelper.html#method-i-number_to_rounded).

When a precision is specified, it will apply to the fraction digits:

```ruby
> ActiveSupport::NumberHelper.number_to_rounded(1.0, precision: 2)
=> "1.00"
```

Unless you include `significant: true` in which case precision will refer to
the number of signficant digits:

```ruby
> ActiveSupport::NumberHelper.number_to_rounded(1.0, precision: 2, significant: true)
=> "1.0"
```

Because this is for display purposes, the return value is a string. You can
further specify that insignificant zeros are stripped from the result:

```ruby
> ActiveSupport::NumberHelper.number_to_rounded(1.0, precision: 2, significant: true, strip_insignificant_zeros: true)
=> "1"
```

And for completeness, here is an example of a number being rounded up:

```ruby
> ActiveSupport::NumberHelper.number_to_rounded(1.29, precision: 2, significant: true)
=> "1.3"
```

[source](https://api.rubyonrails.org/classes/ActiveSupport/NumberHelper.html#method-i-number_to_rounded)

# Schedule Sidekiq Jobs Out Into The Future

The most common way to schedule a [Sidekiq](https://github.com/mperham/sidekiq)
job is with the `perform_async` method. That will queue up your job so that it
is worked as soon as possible.  That may not also be desired. Sometimes you
want a bit more say in when jobs are run.

The `perform_in` and `perform_at` methods can help with scheduling jobs out
into the future.

With `perform_in` we can say how much time from now would be the soonest that
we'd like the job performed.

```ruby
MyWorker.perform_in(10.minutes, arg1, arg2)
```

We can do the same thing with `perform_at`.

```ruby
MyWorker.perform_at(10.minutes.from_now, arg1, arg2)
```

Or we can schedule something out for a specific point in time in the future.

```ruby
MyWorker.perform_at(Date.today.end_of_week, arg1, arg2)
```

[source](https://github.com/mperham/sidekiq/wiki/Scheduled-Jobs)

# Secure Passwords With Rails And Bcrypt

If you are using [`bcrypt`](https://github.com/codahale/bcrypt-ruby) (at
least version 3.1.7), then you can easily add secure password functionality
to an
[ActiveRecord](https://github.com/rails/rails/tree/master/activerecord)
model. First, ensure that the table backing the model has a
`password_digest` column. Then add
[`has_secure_password`](https://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html)
to your model.

```ruby
class User < ActiveRecord::Base
  has_secure_password

  # other logic ...
end
```

You can now instantiate a `User` instance with any required fields as well
as `password` and `password_confirmation`. As long as `password` and
`password_confirmation` match then an encrypted `password_digest` will be
created and stored. You can later check a given password for the user using
the `authenticate` method.

```ruby
user = User.find_by(email: user_params[:email])

if user.authenticate(user_params[:password])
  puts 'That is the correct password!'
else
  puts 'That password did not match!'
end
```

# Select A Select By Selector

Generally when using Capybara to select from a `select` input, I reference it by its `name`
which rails associates with the label:

```ruby
select("Charizard", from: "Pokemon")
```

However, not all forms are going to have a label paired with every `select`
input. We don't want to let our test coverage suffer, so we are going to
need a different way to select. Fortunately, Capybara allows us to chain
`select` off a `find` like so:

```ruby
find('#pokemon_list').select('Charizard')
```

# Select Value For SQL Counts

If you are like me and prefer writing raw SQL over the Arel DSL for counting
stuff in your database, then the `select_value` method will come in handy.
Write a command similar to the following with a type cast to get the count
of _whatever_.

```ruby
> sql = 'select count(*) from posts where published_at is not null'
=> "select count(*) from posts where published_at is not null"
> ActiveRecord::Base.connection.select_value(sql).to_i
   (0.6ms)  select count(*) from posts where published_at is not null
=> 42
```

Writing raw SQL for a simple query like this hardly seems like a win.
However when a count query starts to involve joins or other fanciness, I
find it much clearer to reason about the raw SQL.

# Serialize With fast_jsonapi In A Rails App

Netflix put out a Ruby gem for super fast JSON serialization --
[`fast_jsonapi`](https://github.com/Netflix/fast_jsonapi). It is great for
serializing JSON responses for Rails API endpoints.

First, add `gem 'fast_jsonapi'` to your `Gemfile` and `bundle install`.

Then create the `app/serializers` directory for housing all of your JSON
serializers.

Next you can create a `serializer` that corresponds to the model you want to
serialize:

```ruby
# app/serializers/recipe_serializer.rb
class RecipeSerializer
  include FastJsonapi::ObjectSerializer

  set_id :id
  attributes :name, :source_url
end
```

Last, use it to generate a JSON response in your controller:

```ruby
# app/controllers/recipes_controller.rb
class RecipesController < ApiController
  def index
    render json: RecipeSerializer.new(@current_user.recipes)
  end
end
```

Requests to that endpoint will receive a response that looks something like
this:

```json
{
  data: [
    {
      id: 1,
      attributes: { name: "Old Fashioned", source_url: "http://..." },
    },
    {
      id: 2,
      attributes: { name: "Sazerac", source_url: "http://..." },
    },
  ]
}
```

# Set A Timestamp Field To The Current Time

To set a timestamp field to the current time, you could reach for the `#update`
method like you would when modifying any other field.

```ruby
MagicLink
  .find_by(token: some_token)
  .update(used_at: Time.zone.now)
```

This works, but it's more verbose than is necessary and requires that you
construct the right timestamp for _now_ (time zones and all).

Rails has a more concise and idomatic way of doing this:
[`#touch`](https://api.rubyonrails.org/v6.1.0/classes/ActiveRecord/Persistence.html#method-i-touch).

```ruby
MagicLink
  .find_by(token: some_token)
  .touch(:used_at)
```

Updating a timestamp to the current time is a common action in web
applications, so Rails offers the `#touch` method as a shorthand for doing it.
This will set the given field, in this case `:used_at`, to the current time.
This will also set the `updated_at/on` field.

# Set default_url_options For Entire Application

There are a [number of
ways](https://github.com/rails/rails/issues/29992#issuecomment-575464112) to
set `default_url_options` for the various modules that need them. While the
development server can infer URL options for the most part, it needs them
explicitly defined for `ActionMailer`. You may also see the `ArgumentError:
Missing host to link to! Please provide the :host parameter, set
default_url_options[:host], or set :only_path to true` error when using a URL
helper. That's because the `routes` config also needs to know.

Instead of cobbling together default settings in several different places as
the issues arise, you can define them application-wide like so:

```ruby
# config/environments/development.rb
Rails.application.default_url_options = { host: 'localhost', port: 3000 }

Rails.application.configure do
 # ...
end
```

Add the `default_url_options` to `Rails.application` just outside of the
standard `configure` block in each of your environment config files. Now
everything should know how to generate full URLs.

Note: I've tested this out in a Rails 6.1 application.

[source](https://discuss.rubyonrails.org/t/define-host-so-absolute-urls-work-in-development-and-test/75085/10)

# Set Schema Search Path

By default the schema search path for a PostgreSQL database is going to be
`"$user", public`. Tables created by a Rails migration are going to end up
on the `public` schema by default. If your application has other schemas in
play, then you may want to ensure that those schemas are also on the schema
search path. This can be accomplished by adding the `schema_search_path`
setting to your `database.yml` file. For instance, to include both the
`legacy` and `public` schema in the Postgres search path, add the following
line:

```ruby
schema_search_path: "legacy,public"
```

h/t Jack Christensen

# Set Statement Timeout For All Postgres Connections

The
[`statement_timeout`](postgres/set-a-statement-timeout-threshold-for-a-session.md)
setting in PostgreSQL allows you to head off long running queries and
migrations that could break your deploys and lock up your production tables.

This value can be set to a sensible default across all the connections your
Rails app makes to PostgreSQL. To set it, open up your `config/database.yml`
file and add a `variables` element to the default section.

```yaml
default: &default
  adapter: postgresql
  encoding: unicode
  # For details on connection pooling, see Rails configuration guide
  # https://guides.rubyonrails.org/configuring.html#database-pooling
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  variables:
    statement_timeout: 60000
```

That's 60 seconds in milliseconds. You can avoid the mental math by using a
string argument with a unit such as `s` for seconds.

```yaml
  variables:
    statement_timeout: '60s'
```

If you then execute a long running query, such as:

```ruby
ActiveRecord::Base.connection.execute('select pg_sleep(62)')
```

It will terminate 2 seconds early because of the statement timeout.

[source](https://til.hashrocket.com/posts/b44baf657d-railspg-statement-timeout-)

# Set The Default Development Port

For Rails 5+, Puma has been the default web server that gets installed with new
Rails apps. Puma comes with some configuration in the `config/puma.rb` file.

If you open that file up, you'll see a number of settings that can be
configured. One of them is the `port` that `puma` uses.

```ruby
# Specifies the `port` that Puma will listen on to receive requests; default is 3000.
#
port        ENV.fetch('PORT') { 3000 }
```

It looks for a `PORT` value in the envionrment and uses that if it is present.
That means you could run:

```bash
PORT=5005 rails s
```

and Puma would server the local development server at `localhost:5005`. If that
value is not present, it will fallback to `#fetch`'s block which contains
`3000`.

If you always want to local Rails development server to run at a port other
than `3000`, all you need to do is update that line.

```ruby
port        ENV.fetch('PORT') { 5005 }
```

Now, running `rails s` on its own will start the dev server up at
`localhost:5005`.

[source](https://schneems.com/2017/03/13/puma-ports-and-polish/)

# Show Pending Migrations

Rails comes with a built-in rake task that allows you to check the status
of migrations in the project.

```bash
$ rake db:migrate:status

database: pokemon_development

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20150219143706  Create pokemon table
  down    20150228003340  Create stats table
```

For large projects with lots of migrations, this is going to be a lot of
output, so you can trim it down with a simple `grep`:

```bash
$ rake db:migrate:status | grep '^  down'
  down    20150228003340  Create stats table
```

[source](https://github.com/rails/rails/blob/master/activerecord/lib/active_record/railties/databases.rake#L91)

# Show Rails Models With Pry

With the [`pry-rails`](https://github.com/rweng/pry-rails) gem, you get some
extra goodies in the Rails console for your project. One of those goodies is
`show-models`, a command for printing out a list of all models in the rails
project. Add and bundle the `pry-rails` gem, run `rails c`, and then run
`show-models` to give it a go.

```
> show-models
Pokemon
  id: integer
  name: string
  level: integer
  pokemon_type: varchar
  belongs_to Trainer
  created_at: datetime
  updated_at: datetime
Trainer
  id: integer
  name: string
  has_many Pokemons
```

# Show Rails Routes With Pry

In [Show Rails Models With Pry](show-rails-models-with-pry.md), I showed
that [`pry-rails`](https://github.com/rweng/pry-rails) comes with some handy
console commands. In addition to being able to list all your Rails models,
you can list all the routes for your application using `show-routes`.

I get the following output by using that command in a small blog project:

```
> show-routes
              Prefix Verb   URI Pattern                     Controller#Action
                root GET    /                               application#index
markdownify_articles POST   /articles/markdownify(.:format) articles#markdownify
            articles POST   /articles(.:format)             articles#create
         new_article GET    /articles/new(.:format)         articles#new
        edit_article GET    /articles/:id/edit(.:format)    articles#edit
             article GET    /articles/:id(.:format)         articles#show
                     PATCH  /articles/:id(.:format)         articles#update
                     PUT    /articles/:id(.:format)         articles#update
               users POST   /users(.:format)                users#create
            new_user GET    /users/new(.:format)            users#new
                user GET    /users/:id(.:format)            users#show
            sessions POST   /sessions(.:format)             sessions#create
         new_session GET    /sessions/new(.:format)         sessions#new
             session DELETE /sessions/:id(.:format)         sessions#destroy
              signin GET    /signin(.:format)               sessions#new
                     POST   /signin(.:format)               sessions#create
              signup GET    /signup(.:format)               users#new
```

# Skip Validations When Creating A Record

Validations on your
[ActiveRecord](https://api.rubyonrails.org/classes/ActiveRecord/Base.html)
models are there for a reason. They provide application-level feedback about
data that doesn't meet business requirements.  In many cases those validations
should also be pushed down to the database-layer in the form of constraints.

Sometimes, though rarely and probably only in a testing or development context,
you'll want to skip validations.

This is how you can do that when creating a new record:

```ruby
user = User.new(
  name: 'Josh',
  email: '',
  password: SecureRandom.uuid
)

user.valid?
#=> false
user.errors.messages
#=> {:email=>["can't be blank"]}

user.save(validate: false)
```

After newing-up an object with invalid data, you can [save it with the
`validate` option set to
`false`](https://api.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-save).
This will skip ActiveRecord validations.

Note: If you also have a database-layer constraint, this won't work. Perhaps
for your use case you can get by with a new non-persisted record.

# Specify New Attributes For #find_or_create_by

The ActiveRecord
[`#find_or_create_by`](https://apidock.com/rails/v4.0.2/ActiveRecord/Relation/find_or_create_by)
method is a handy way to get an object that represents a record. It will
attempt to look up that record, usually based on a unique value or set of
values. If it can find one, then that's the record you get. If nothing is
found, then it will create a new record.

New records tend to need more data than just the unique lookup attribute. There
are a couple ways these other attributes can be specified.

The first is by giving `#find_or_create_by` a block.

```ruby
User.find_or_create_by(email: "some@email.com") do |new_user|
  new_user.admin = false
  new_user.password = params[:password]
  new_user.password_confirm = params[:password_confirm]
end
```

Another approach is to precede the `#find_or_create_by` call with a
[`#create_with`](https://apidock.com/rails/ActiveRecord/QueryMethods/create_with)
call.


```ruby
User.create_with(
  admin: false,
  password: params[:password],
  password_confirm: params[:password_confirm]
).find_or_create_by(email: "some@email.com")
```

In both cases, the extra attributes will not be applied to the `User` record in
the case of a _find_; they are only used in the case of a _create_.

# Temporarily Disable strong_params

I was recently doing a Rails upgrade. This old version of the app wasn't
prepared to deal with `strong_params` right away. I already had a pile of
migration path TODOs and fixes on top of addressing the `strong_params` issue.
I decided to put off dealing with `strong_params` by adding this line the main
controller.

```ruby
# app/controllers/application_controller.rb
def params
  request.parameters
end
```

This bypasses the `strong_params` check for all controllers inheriting from
`ApplicationController`.

Remember, this is a _temporary_ fix. You'll eventually want to adhere to
`strong_params` for your mass assignments.

[source](https://stackoverflow.com/a/41163978/535590)

# Test If An Instance Variable Was Assigned

When testing Rails controller actions, you'll often be making assertions about
the response to your test request. You may also want to assert about the
instance variables being set, as those are headed for your view layer.

For instance, if an instance variable `@metadata` is supposed to be set in a
`#show` controller action, you can assert that it is with [RSpec's
`assigns`](https://relishapp.com/rspec/rspec-rails/docs/controller-specs):

```ruby
describe "when given valid params" do
  it "sets the metadata" do
    get :show, params: valid_params

    expect(assigns(:metadata)).to match(
      identifier: "abc123",
      session_id: "fe98f08c-bf2f-4749-9f81-071d9cc7720e",
    )
  end
end
```

[source](https://stackoverflow.com/questions/2051373/how-to-test-instance-variable-was-instantiated-in-controller-with-rspec)

# Test If deliver_later Is Called For A Mailer

There are many ways to test in your controller whether emails are going out. A
concise and quick way to check is just to see if a `deliver_later` happened.

Depending on how your test environment is configured, this could look one of
two ways.

If you have your `queue_adapter` set to
[`:inline`](https://api.rubyonrails.org/classes/ActiveJob/QueueAdapters/InlineAdapter.html),
then a `deliver_later` will happen synchronously. So, the email will
immediately end up in the `deliveries` box.

```ruby
expect {
  post :password_reset, params: valid_params
}.to change { ActionMailer::Base.deliveries.count }.by(1)
```

The behavior is a bit different if your `queue_adapter` is set to something
like
[`:test`](https://api.rubyonrails.org/classes/ActiveJob/QueueAdapters/TestAdapter.html).
In this case, the email is going to be queued in the app's job queue. Since it
is not immediately being sent, the expectation will have to be about the job
queue instead.

```ruby
expect {
  post :password_reset, params: valid_params
}.to have_enqueued_job(ActionMailer::DeliveryJob)
```

We can even dig into more specifics like this:

```ruby
expect {
  post :password_reset, params: valid_params
}.to have_enqueued_job(ActionMailer::DeliveryJob)
  .with('UserMailer', 'password_reset', 'deliver_later', Integer)
```

# Test Out URL And Path Helpers In The Console

Rails has fancy metaprogrammed URL and path helpers generated from the
`config/routes.rb` file. There is a ton of configurability to these routes. It
can sometimes be hard to know exactly how they'll behave or what the generated
route helper will look like. In those cases, we may want to test them out in
the console.

The Rails console doesn't have the same things autoloaded as mailers and views
where we tend use these route helpers. So, we can reference them through
`Rails.application.routes.url_helpers`.

From there we can run both `*_path` route helpers.

```ruby
> Rails.application.routes.url_helpers
    .api_v1_post_with_slugged_title_path(
      slug: 123,
      slugged_title: 'a-recent-path'
    )

=> "/api/v1/posts/123/a-recent-path"
```

and `*_url` path helpers.

```ruby
> Rails.application.routes.url_helpers
    .api_v1_post_with_slugged_title_url(
      slug: 123,
      slugged_title: 'a-recent-path'
    )

=> "http://localhost:3000/api/v1/posts/123/a-recent-path"
```

For the `*_url` path helpers, make sure you have [`default_url_options`
set](set-default-url-options-for-entire-application.md).

[source](https://stackoverflow.com/a/13553422/535590)

# Truncate Almost All Tables

The
[`database_cleaner`](https://github.com/DatabaseCleaner/database_cleaner)
gem is a handy way to make sure you have a consistent database context for
each test example or suite. One `database_cleaner` strategy that can be used
is the `truncation` strategy. This truncates the data from all the tables by
default. This is not ideal for *fixed* tables that contain domain-specific
data because you end up having to do way more test setup than should be
necessary. Fortunately, specific tables can be excepted by the truncation
strategy using the `except` option.

For instance, if we have a standard set of roles for users of our
application, we can except that table from truncation with a line like the
following in our `rails_helper.rb` file:

```ruby
DatabaseCleaner.strategy = :truncation, {:except => %w[roles]}
```

# Update Column Versus Update Attribute

Rails offers a whole variety of methods for making updates to the ActiveRecord
objects in your app. Two unique, infrequently-used ones are
[`#update_column`](https://devdocs.io/rails~5.2/activerecord/persistence#method-i-update_column)
and
[`#update_attribute`](https://devdocs.io/rails~5.2/activerecord/persistence#method-i-update_attribute).
What is unique about them is that they are both ways of updating a record while
skipping the validations defined on the model.

So, how do they differ?

A call to `#update_attribute` is still going to trigger any callbacks defined
on the model and it will touch the `update_at` column. On the other hand,
`#update_column` can be thought of as a way of directly interacting with the
database -- callbacks are skipped and you are truly only touching the specified
column, `updated_at` is left as is.

The docs have this recommendation for `#update_attribute`:

> This is especially useful for boolean flags on existing records.

And for `#update_column`, they say this:

> This is the fastest way to update attributes because it goes straight to the
> database, but take into account that in consequence the regular update
> procedures are totally bypassed.

These are both useful in specific situations, but be sure to know their
differences and to use them with caution.

# Upgrading Your Manifest For Sprocket's 4

If you're upgrading [Rails](https://github.com/rails/rails) and it involves
bumping the [Sprockets](https://github.com/rails/sprockets) dependency from 3.x
to 4.x, you may need to update your `manifest.js`.

> Since the default logic for determining top-level targets changed, you might
> find some files that were currently compiled by sprockets for delivery to
> browser no longer are. You will have to edit the `manifest.js` to specify
> those files.

> The `manifest.js` file is meant to specify what files to use as a top-level
> target using sprockets methods `link`, `link_directory`, and `link_tree`.

You can specify what top-level assets like so:

```javascript
# app/assets/config/manifest.js

//= link_tree ../images
//= link_directory ../javascripts .js
//= link_directory ../stylesheets .css
//= link some_file.xml
//= link some/nested/style.css
```

Read more about the [upgrade process
here](https://github.com/rails/sprockets/blob/master/UPGRADING.md#manifestjs)
as well as in [this blog
post](https://eileencodes.com/posts/the-sprockets-4-manifest/).

# Verify And Read A Signed Cookie Value

Let's say a value was added as a [signed
cookie](https://apidock.com/rails/ActionDispatch/Cookies/CookieJar/signed) in a
request:

```ruby
cookies.signed[:discount] = 45
#=> Set-Cookie: discount=BAhpMg==--2c1c6906c90a3bc4fd54a51ffb41dffa4bf6b5f7; path=/
```

Generally to verify and read that value, you'd grab it from the signed cookies
included in the request.

```ruby
cookies.signed[:discount]
#=> 45
```

What if you have the signed cookie value, but not in the context of a `cookies`
object?

You can build a cookie jar from the current request and read the verified value
from that.

```ruby
cookie_value = 'BAhpMg==--2c1c6906c90a3bc4fd54a51ffb41dffa4bf6b5f7'
cookie_hash = { discount: cookie_value }

cookie_jar = ActionDispatch::Cookies::CookieJar.build(request, cookie_hash)

cookie_jar.signed[:discount]
#=> 45
```

It is also possible to [Base64 decode the
value](https://blog.bigbinary.com/2013/03/19/cookies-on-rails.html), however
that doesn't ensure that the value hasn't been tampered with.

[source](https://philna.sh/blog/2020/01/15/test-signed-cookies-in-rails/)

# Where Am I In The Partial Iteration?

Let's say I am going to render a collection of posts with a post partial.

```erb
<%= render collection: @posts, partial: "post" %>
```

The
[`ActionView::PartialIteration`](http://api.rubyonrails.org/classes/ActionView/PartialIteration.html)
module provides a couple handy methods when rendering collections.
I'll have access in the partial template to `#{template_name}_iteration`
(e.g. `post_iteration`) which will, in turn, give me access to `#index`,
`#first?`, and `#last?`.

This is great if I need to do something special with the first or last item
in the collection or if I'd like to do some sort of numbering based on the
index of each item.

[source](http://stackoverflow.com/questions/13397848/rails-render-collection-partial-getting-size-of-collection-inside-partial)

h/t Josh Davey

# Wipe Out All Precompiled Assets

You can clean up precompiled assets using:

```bash
$ rails assets:clean
```

This command is built to be safe for situations like rolling deploys. Any
assets that are still being used will not be cleaned up.

If you really want to wipe out _all_ precompiled assets, you should _clobber_
them:

```bash
$ rails assets:clobber
```

[source](https://edgeguides.rubyonrails.org/command_line.html#rails-assets)

# Write Reversible Migration To Set Default

You can use the `change_column_default` method to alter the default value of a
column. If the column doesn't have a default, then you'd essentially be
changing the default from `nil` to _some value_.

```ruby
def up
  change_column_default :books, :published, false
end

def down
  change_column_default :books, :published, nil
end
```

This is fine, but you can write the migration as a single, reversible `change`
method using the `:from` and `:to` options.

```ruby
def change
  change_column_default :books, :published, from: nil, to: false
end
```

When you migrate, the default will be set to `false`. When you rollback, the
default will be removed.

[source](https://blog.arkency.com/how-to-add-a-default-value-to-an-existing-column-in-a-rails-migration/)

# Write Safer Where Clauses With Placeholders

Ruby has a super ergonomic syntax for string interpolation. This can make it
tempting to build up ActiveRecord `where` clauses like so:

```ruby
def get_book_by_title(title)
  Book.where("lower(title) = #{title.downcase}")
end
```

The `where` clause, as written, is vulnerable to a SQL injection attack.

There are two kinds of placeholder syntax that you can use instead handle
sanitization of the SQL.

```ruby
def get_book_by_title(title)
  Book.where("lower(title) = ?", title.downcase)
end
```

You can use multiple `?` in the query and they same number of following
arguments will be interpolated in order.

There is also the keyword placeholder syntax which can give you more
flexibility and make the SQL read more clearly.

```ruby
def get_book_by_title(title)
  Book.where("lower(title) = :title", title: title.downcase)
end
```

[source](https://devdocs.io/rails~5.2/activerecord/querymethods#method-i-where)

