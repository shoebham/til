### Category ruby

---

 - [A Basic Case Statement](#a-basic-case-statement)
 - [A Shorthand For Rerunning Failed Tests With RSpec](#a-shorthand-for-rerunning-failed-tests-with-rspec)
 - [Add Comments To Regex With Free-Spacing](#add-comments-to-regex-with-free-spacing)
 - [Add Linux As A Bundler Platform](#add-linux-as-a-bundler-platform)
 - [Are They All True?](#are-they-all-true?)
 - [Assert About An Object's Attributes With RSpec](#assert-about-an-object's-attributes-with-rspec)
 - [Assoc For Hashes](#assoc-for-hashes)
 - [Block Comments](#block-comments)
 - [Build HTTP And HTTPS URLs](#build-http-and-https-urls)
 - [Chaining Multiple RSpec Change Matchers](#chaining-multiple-rspec-change-matchers)
 - [Check For Any Overlaps In List Of Ranges](#check-for-any-overlaps-in-list-of-ranges)
 - [Check If An Object Includes A Module](#check-if-an-object-includes-a-module)
 - [Check Return Status Of Running A Shell Command](#check-return-status-of-running-a-shell-command)
 - [Click On Text With Capybara](#click-on-text-with-capybara)
 - [Colorful Output With MiniTest](#colorful-output-with-minitest)
 - [Comparing Class Hierarchy Relationships](#comparing-class-hierarchy-relationships)
 - [Comparing Arrays In RSpec](#comparing-arrays-in-rspec)
 - [Construct A Constant From A String](#construct-a-constant-from-a-string)
 - [Convert A Unix Epoch Timestamp To A Time Object](#convert-a-unix-epoch-timestamp-to-a-time-object)
 - [Create an Array of Stringed Numbers](#create-an-array-of-stringed-numbers)
 - [Create A CSV::Table Object](#create-a-csv::table-object)
 - [Create A Hash From An Array Of Arrays](#create-a-hash-from-an-array-of-arrays)
 - [Create Listing Of All Middleman Pages](#create-listing-of-all-middleman-pages)
 - [Create Named Structs With Struct.new](#create-named-structs-with-struct.new)
 - [Create Thumbnail Image For A PDF](#create-thumbnail-image-for-a-pdf)
 - [Defaulting To Frozen String Literals](#defaulting-to-frozen-string-literals)
 - [Define A Custom RSpec Matcher](#define-a-custom-rspec-matcher)
 - [Define A Method On A Struct](#define-a-method-on-a-struct)
 - [Destructure The First Item From An Array](#destructure-the-first-item-from-an-array)
 - [Destructuring Arrays In Blocks](#destructuring-arrays-in-blocks)
 - [Disassemble Some Codes](#disassemble-some-codes)
 - [Double Splat To Merge Hashes](#double-splat-to-merge-hashes)
 - [Edit Previous Parts Of The Pry Buffer History](#edit-previous-parts-of-the-pry-buffer-history)
 - [Editing Code In Pry](#editing-code-in-pry)
 - [Encode A String As URL-safe Base64](#encode-a-string-as-url-safe-base64)
 - [Enumerate A Pairing Of Every Two Sequential Items](#enumerate-a-pairing-of-every-two-sequential-items)
 - [Evaluating One-Off Commands](#evaluating-one-off-commands)
 - [Exclude Values From An Array](#exclude-values-from-an-array)
 - [Expect A Method To Be Called And Actually Call It](#expect-a-method-to-be-called-and-actually-call-it)
 - [Extract A Column Of Data From A CSV File](#extract-a-column-of-data-from-a-csv-file)
 - [FactoryGirl Sequences](#factorygirl-sequences)
 - [Fail](#fail)
 - [Find The Min And Max With A Single Call](#find-the-min-and-max-with-a-single-call)
 - [Finding The Source of Ruby Methods](#finding-the-source-of-ruby-methods)
 - [Generate A Signed JWT Token](#generate-a-signed-jwt-token)
 - [Generate Ruby Version And Gemset Files With RVM](#generate-ruby-version-and-gemset-files-with-rvm)
 - [Get Info About Your Ruby Gems Environment](#get-info-about-your-ruby-gems-environment)
 - [Identify Outdated Gems](#identify-outdated-gems)
 - [If You Detect None](#if-you-detect-none)
 - [Iterate With An Offset Index](#iterate-with-an-offset-index)
 - [Include Extra Context In A Honeybadger Notify](#include-extra-context-in-a-honeybadger-notify)
 - [Ins And Outs Of Pry](#ins-and-outs-of-pry)
 - [Invoking Rake Tasks Multiple Times](#invoking-rake-tasks-multiple-times)
 - [IRB Has Built-In Benchmarking With Ruby 3](#irb-has-built-in-benchmarking-with-ruby-3)
 - [Jump Out Of A Nested Context With Throw/Catch](#jump-out-of-a-nested-context-with-throw/catch)
 - [Last Raised Exception In The Call Stack](#last-raised-exception-in-the-call-stack)
 - [Limit Split](#limit-split)
 - [List The Running Ruby Version](#list-the-running-ruby-version)
 - [Listing Local Variables](#listing-local-variables)
 - [Map With Index Over An Array](#map-with-index-over-an-array)
 - [Mock Method Chain Calls With RSpec](#mock-method-chain-calls-with-rspec)
 - [Mocking Requests With Partial URIs Using Regex](#mocking-requests-with-partial-uris-using-regex)
 - [Named Regex Captures Are Assigned To Variables](#named-regex-captures-are-assigned-to-variables)
 - [Navigate Back In The Browser With Capybara](#navigate-back-in-the-browser-with-capybara)
 - [Next And Previous Floats](#next-and-previous-floats)
 - [Or Operator Precedence](#or-operator-precedence)
 - [Override The Initial Sequence Value](#override-the-initial-sequence-value)
 - [Parallel Bundle Install](#parallel-bundle-install)
 - [Parse JSON Into An OpenStruct](#parse-json-into-an-openstruct)
 - [Parsing A CSV With Quotes In The Data](#parsing-a-csv-with-quotes-in-the-data)
 - [Pass A Block To Count](#pass-a-block-to-count)
 - [Passing Arbitrary Methods As Blocks](#passing-arbitrary-methods-as-blocks)
 - [Passing Arguments To A Rake Task](#passing-arguments-to-a-rake-task)
 - [Pattern Match Values From A Hash](#pattern-match-values-from-a-hash)
 - [Percent Notation](#percent-notation)
 - [Question Mark Operator](#question-mark-operator)
 - [Rake Only Lists Tasks With Descriptions](#rake-only-lists-tasks-with-descriptions)
 - [Read The First Line From A File](#read-the-first-line-from-a-file)
 - [Rendering ERB](#rendering-erb)
 - [Replace The Current Process With An External Command](#replace-the-current-process-with-an-external-command)
 - [Require Entire Gemfile In Pry Session](#require-entire-gemfile-in-pry-session)
 - [Rerun Only Failures With RSpec](#rerun-only-failures-with-rspec)
 - [Retry A Block After An Exception](#retry-a-block-after-an-exception)
 - [Returning With Sequel](#returning-with-sequel)
 - [rexml Is A Bundled Gem As Of Ruby 3.0.0](#rexml-is-a-bundled-gem-as-of-ruby-3.0.0)
 - [Run An Older Version Of Bundler](#run-an-older-version-of-bundler)
 - [Running A Single MiniTest Example](#running-a-single-minitest-example)
 - [Safe Navigation Operator](#safe-navigation-operator)
 - [Scripting With RVM](#scripting-with-rvm)
 - [Scroll To Top Of Page With Capybara](#scroll-to-top-of-page-with-capybara)
 - [Set RVM Default Ruby](#set-rvm-default-ruby)
 - [Show Public Methods With Pry](#show-public-methods-with-pry)
 - [Silence The Output Of A Ruby Statement In Pry](#silence-the-output-of-a-ruby-statement-in-pry)
 - [Single And Double Quoted String Notation](#single-and-double-quoted-string-notation)
 - [Skip Specific CVEs When Auditing Your Bundle](#skip-specific-cves-when-auditing-your-bundle)
 - [Squeeze Out The Extra Space](#squeeze-out-the-extra-space)
 - [String Interpolation With Instance Variables](#string-interpolation-with-instance-variables)
 - [Summing Collections](#summing-collections)
 - [Triple Equals: The Case Equality Operator](#triple-equals:-the-case-equality-operator)
 - [Turn Key And Value Arrays Into A Hash](#turn-key-and-value-arrays-into-a-hash)
 - [Turning Any Class Into An Enumerator](#turning-any-class-into-an-enumerator)
 - [Turning Things Into Hashes](#turning-things-into-hashes)
 - [Uncaught Exceptions In Pry](#uncaught-exceptions-in-pry)
 - [`undef_method` And The Inheritance Hierarchy](#`undef_method`-and-the-inheritance-hierarchy)
 - [Uninstall Specific Version Of A Ruby Gem](#uninstall-specific-version-of-a-ruby-gem)
 - [Unpacking Strings Into Binary](#unpacking-strings-into-binary)
 - [Up And Down With Integers](#up-and-down-with-integers)
 - [Update The Gemfile Bundled With Version](#update-the-gemfile-bundled-with-version)
 - [Use A Case Statement As A Cond Statement](#use-a-case-statement-as-a-cond-statement)
 - [Use dotenv In A Non-Rails Project](#use-dotenv-in-a-non-rails-project)
 - [Use Tap For Better Test Data Setup](#use-tap-for-better-test-data-setup)
 - [Using BCrypt To Create And Check Hashed Passwords](#using-bcrypt-to-create-and-check-hashed-passwords)
 - [What To Do When You Don't Rescue](#what-to-do-when-you-don't-rescue)
 - [Who Are My Ancestors?](#who-are-my-ancestors?)
 - [Wrap Things In An Array, Even Hashes](#wrap-things-in-an-array,-even-hashes)
 - [Zero Padding](#zero-padding)

---

# A Basic Case Statement

The syntax for case statements (or switch statements) is a little different for
each language. I often confuse the Ruby and JavaScript syntax or wonder if I
need to be using a colon anywhere.

Here is a demonstration of how to write a basic case statement in Ruby.

```ruby
case ['taco', 'burrito', 'pizza', nil].sample
when 'taco'
  puts 'Taco, eh. Carne asada or al pastor?'
when 'burrito'
  puts 'Burrito, eh. Want it smothered?'
when 'pizza'
  puts 'Pizza, eh. Cheese or pepperoni?'
else
  puts 'What do you want to eat?'
end
```

This next example demonstrates two things. First, you can make things terser
with the `then` syntax. Second, the case statement does an implicit return of
whatever the last value is from the evaluated case. So it can be used as part
of a variable assignment.

```ruby
question =
  case ['taco', 'burrito', 'pizza', nil].sample
  when 'taco' then 'Taco, eh. Carne asada or al pastor?'
  when 'burrito' then 'Burrito, eh. Want it smothered?'
  when 'pizza' then 'Pizza, eh. Cheese or pepperoni?'
  else 'What do you want to eat?'
  end

puts question
```

# A Shorthand For Rerunning Failed Tests With RSpec

After running a group of tests -- whether it is the entire suite or just the
tests in a file -- you may find that you have a few failures. Often the goal is
to focus in on these failures and get back to a green test suite. Rather than
rerunning everything each time you make a change, you can instruct `rspec` to
just rerun the tests that failed. This can be done with the `--only-failures`
flag or `--on` flag for short.

# Add Comments To Regex With Free-Spacing

Ruby's regex syntax supports a [Free-Spacing
mode](https://ruby-doc.org/core-3.0.1/Regexp.html#class-Regexp-label-Free-Spacing+Mode+and+Comments).
When this mode is enabled, all the literal whitespace in the regular expression
is ignored and comments can be included at the end of lines. This is enabled by
appending the `x` option at the end of the regex.

Here is a regex with Free-Spacing mode enabled (see the `x` at the end).

```ruby
simple_email = /\A.+@.+\z/x
```

Though it's enabled, it is not really being used.

Here is the same regular expression, but this time I've spaced it out and added
comment annotation to make the regex easier to understand.

```ruby
simple_email = /
  \A  # beginning of the string
  .+  # any opening characters
  @   # the email's `@` symbol
  .+  # the rest of the email
  \z  # the end of the string
/x
```

To be sure the extra space and comments aren't messing things up, here is some
code to test it out.

```ruby
test_emails = [
  'taco',
  'email@example.com',
  'more.complex+email@example.com',
  '@'
]

test_emails.each do |email|
  if (simple_email =~ email) == 0
    puts "#{email} looks like an email"
  else
    puts "#{email} may not be an email"
  end
end
```

[source](https://twitter.com/jasonrudolph/status/1413240725064519681?s=20)

# Add Linux As A Bundler Platform

With a locally developed Ruby project on Mac OSX, I have `darwin` specified as
the _platform_ in the `Gemfile.lock`.

```ruby
PLATFORMS
  x86_64-darwin-19
```

When setting up CI for my project on a linux container, I'd get an error like
this:

> Your bundle only supports platforms ["x86_64-darwin-19"] ...

This platform incompatability can be solved with by adding linux as a platform
and re-resolving the lock file. This is done with [`bundle
lock`](https://bundler.io/v2.0/man/bundle-lock.1.html) and the `--add-platform`
flag.

```bash
$ bundle lock --add-platform x86_64-linux
```

If all existing gems work with the new linux platform, the command will succeed
and the updated `Gemfile.lock` will have the following `PLATFORMS` section.

```ruby
PLATFORMS
  x86_64-darwin-19
  x86_64-linux
```

[source](https://github.com/rubygems/rubygems/issues/4269#issuecomment-759591430)

# Are They All True?

There is a method on `Enumerable` that allows you to check against
everything in a collection. This is the `all?` method.
For instance, if you want to check if an array of values are all
truthy, you can call it without arguments:

```ruby
> [true, 1, ''].all?
# true
> [true, false, true].all?
# false
```

You can also pass it a block which is helpful if you want to check an
attribute or method on a collection of objects, like so:

```ruby
> employees.all?(&:salaried?)
# true
> [1,2,3,4,5].all?(&:odd?)
# false
```

# Assert About An Object's Attributes With RSpec

When testing an object that gets created as the result of some process, it can
be useful to assert about the attributes of that object. Not all of the
attributes are relevant and some can be hard to reliably test. Rather than
asserting about the result of calling `#attributes` or `#to_h` on an object, we
can focus in with the [`have_attributes`
matcher](https://relishapp.com/rspec/rspec-expectations/docs/built-in-matchers/have-attributes-matcher)
provided by RSpec.

```ruby
RSpec.describe "have_attributes" do
  it "can assert on an ActiveRecord object" do
    book = Book.create(title: "Fledling", isbn: "123")

    expect(book).to have_attributes(title: "Fledgling", isbn: "123")
  end

  it "can assert on a Struct" do
    Name = Struct.new(:first, :last)
    some_name = Name.new("Liz", "Lemon")

    expect(some_name).to have_attributes(first: "Liz")
  end
end
```

In this example we were able to assert about all or just a subset of the
attributes on both an `ActiveRecord` object and a `Struct`.

See [the docs](https://relishapp.com/rspec/rspec-expectations/docs/built-in-matchers/have-attributes-matcher) for more details.

# Assoc For Hashes

Ruby's Hash class comes with a method, `assoc`, which is good for grabbing
both the key and value from a hash. If the given key matches it returns a
two element array with the key and value.

```ruby
> stuff = {a: 1, b: 2, c: 3}
=> {a: 1, b: 2, c: 3}
> stuff.assoc(:c)
=> [:c, 3]
```

If a key is used that doesn't exist in the hash, then it simply returns nil.

```ruby
> {}.assoc(:c)
=> nil
```

# Block Comments

Ruby supports (ugly) block comments. They look like this:

```ruby
=begin
This is a block comment.

I can put whatever I want in here.
=end
def do_something
  ...
end
```

[source](http://stackoverflow.com/questions/536760/block-commenting-in-ruby)

# Build HTTP And HTTPS URLs

There are two modules you can use to build URLs in Ruby. The `URI::HTTP` module
will build URLs with the `http` protocol. And then to build URLs with the
`https` protocol, you can reach for the `URI::HTTPS` module.

We can specify just the `host` and optionally include a `port` if that is
needed.

Here is `URI::HTTP` in action.

```ruby
> URI::HTTP.build(host: 'example.com', port: 3000)
=> #<URI::HTTP http://example.com:3000>

> URI::HTTP.build(host: 'example.com', port: 3000, protocol: 'https')
=> #<URI::HTTP http://example.com:3000>
```

Note that we can try to override the protocol, but it will be ignored.

Here is the `URI::HTTPS` module.

```ruby
> URI::HTTPS.build(host: 'example.com', port: 3000)
=> #<URI::HTTPS https://example.com:3000>
```

If we want the URL as a string, we can call `#to_s` on it.

```ruby
> URI::HTTPS.build(host: 'example.com', port: 3000).to_s
=> "https://example.com:3000"
```

We can even include the `path`, though be sure to include the leading slash.

```ruby
> URI::HTTP.build(host: 'example.com', port: 3000, path: '/taco/bell')
=> #<URI::HTTP http://example.com:3000/taco/bell>

> URI::HTTP.build(host: 'example.com', port: 3000, path: 'taco/bell')
URI::InvalidComponentError: bad component(expected absolute path component): taco/bell
from /Users/jbranchaud/.asdf/installs/ruby/2.6.6/lib/ruby/2.6.0/uri/generic.rb:761:in `check_path'
```

[source](https://ruby-doc.org/stdlib-2.5.1/libdoc/uri/rdoc/URI/HTTP.html)

# Chaining Multiple RSpec Change Matchers

It can be handy to use RSpec's `change` matchers to determine if some method
or process creates a new record.

```ruby
expect{ Registration.create(attrs) }.to change{ User.count }.by(1)
```

But what if we are testing a method that creates a couple different records
in the system?

RSpec allows us to chain together `change` matchers with `and`. Consider
this additional contrived example.

```ruby
expect {
  Project.generate(attrs)
}.to change{ Project.count }.by(1).and \
     change{ User.count }.by(1)
```

In addition to keeping our tests tight and concise, this approach gives
some pretty nice output on failure.

If we were just beginning our implementation with a failing test, we'd see a
multi-part failure like the following.

```ruby
Failure/Error:
  expect {
    Project.generate(attrs)
  }.to change{ Project.count }.by(1).and \
       change{ User.count }.by(1)

     expected result to have changed by 1, but was changed by 0

  ...and:

     expected result to have changed by 1, but was changed by 0
```

# Check For Any Overlaps In List Of Ranges

If you have a list of things, such as meetings, you may want to be able to tell
if there are any conflicts. You could determine that by finding any overlaps in
their timeslots.

Ranges are a good way to represent any span of data, including a timeslot.

To do this in Ruby, we'll need two pieces. First, a way to determine if two
`Range` objects are overlapping. Second, an iterative utility for comparing
each range to every other range.

Here is an `overlaps?` method that uses `Range#begin` and `Range#end`.

```ruby
def overlaps?(range1, range2)
  range1.begin <= range2.end && range2.begin <= range1.end
end
```

And here is an `any_overlaps?` method to find any overlaps over a list of
ranges.

```ruby
def any_overlaps?(ranges)
  ranges.each_with_index do |range1, i|
    ranges.each_with_index do |range2, j|
      return true if i != j && overlaps?(range1, range2)
    end
  end

  false
end

puts any_overlaps?([(1..2), (3..4)]) #=> false
puts any_overlaps?([(1..2), (2..4)]) #=> true
puts any_overlaps?([(3..4), (1..5)]) #=> true
```

This second method isn't optimized, but it will work just fine for small lists
of ranges.

[source](https://stackoverflow.com/questions/39934266/check-if-two-ranges-overlap-in-ruby)

# Check If An Object Includes A Module

You may want to know if an object's class includes a module because that will
tell you something about the object's behavior. It is another way of asking if
an object responds to a method or set of methods, assuming you know what
methods the module provides.

This can be done with the [`Module#include?`
method](https://ruby-doc.org/core-3.0.0/Module.html#method-i-include-3F).

```ruby
# assuming some object book of type Book that includes Rateable
> book.class
=> Book
> book.class.include?(Rateable)
=> true

# assuming some object author of type Author that doesn't include Rateable
> author.class
=> Author
> author.class.include?(Rateable)
=> false
```

[source](https://stackoverflow.com/a/28667632/535590)

# Check Return Status Of Running A Shell Command

There are [many
ways](http://tech.natemurray.com/2007/03/ruby-shell-commands.html) to run a
shell command in a Ruby context. One of the most common is to place the command
inside backticks. It runs the command in a subshell.

The standard output (`stdout`) from running the command is the return value of
the statement. Ruby also captures details about the previously run command in
the global `$?` variable.


```ruby
> `true`
=> ""
> $?.exitstatus
=> 0

> `false`
=> ""
> $?.exitstatus
=> 1

> `echo 'hello' && exit 2`
=> "hello\n"
> $?
=> #<Process::Status: pid 12284 exit 2>
> $?.exitstatus
=> 2
```

The value captured in `$?` is a `Process::Status` object. It can tell us the
exit status of the process with `#exitstatus`.

# Click On Text With Capybara

Traditionally, web apps have clickable text in the form of links and buttons.
[Capybara's
`click_on`](https://www.rubydoc.info/github/jnicklas/capybara/Capybara/Node/Actions#click_link_or_button-instance_method)
method is made for just this.

```ruby
click_on("Home") # for <a ... >Home</a>
click_on("Submit") # for <button ...>Submit</button>
```

A lot of more modern, JS-heavy apps stick click handlers on all kinds of
elements. If you want to test what happens when you click some text that is not
a link or button, `click_on` won't work. Instead, you'll need to find the
element and
[`click`](https://rubydoc.info/github/jnicklas/capybara/master/Capybara/Node/Element#click-instance_method)
on it.

```ruby
find("span", text: "Click Me").click
```

# Colorful Output With MiniTest

Ruby's
[`MiniTest`](http://ruby-doc.org/stdlib-2.0.0/libdoc/minitest/rdoc/MiniTest.html)
is a minimal testing framework that you can easily drop-in to any Ruby
project. For those used to using [`RSpec`](http://rspec.info/) with it's fancy
red/green output, MiniTest can be a little disappointing. It prints boring,
uncolored text to the screen that lacks visual feedback. Fortunately, red
and green coloring can be added with
[`minitest/reporters`](https://github.com/kern/minitest-reporters).

Update your `Gemfile`:

```ruby
gem 'minitest-reporters'
```

Then require and configure `minitest-reporters` in your testing setup file
(e.g. `test/test_helper.rb`):

```ruby
require 'minitest/reporters'
Minitest::Reporters.use! [Minitest::Reporters::DefaultReporter.new(:color => true)]
```

You can now enjoy that Red, Green, Refactor cycle.

# Comparing Class Hierarchy Relationships

The comparator methods (`<`,`>`, etc.) can be useful for a lot of things. In
Ruby, they can be used to compare classes in order to understand how they
relate to one another on the class hierarchy.

```ruby
# Fixnum is a subclass of Integer
> Fixnum < Integer
=> true
# Integer is not a subclass of Fixnum
> Integer < Fixnum
=> false
# Fixnum and String are not related to one another
> Fixnum < String
=> nil
```

The `<` operator will tell you if there is a subclass relationship. The `>`
operator will tell you if there is an ancestor relationship. When `nil`
results, it means the two classes do not have a direct relationship.

There are a few more of [these types of
operators](http://ruby-doc.org/core-2.2.2/Module.html#method-i-3C) on the
Module class.

[source](http://kerrizor.com/blog/2015/05/14/serendipity-and-ruby-objects/)

# Comparing Arrays In RSpec

Among its many built-in matchers, RSpec includes a set of array matchers.
One of the array matchers is `match_array` which compares two arrays
independent of ordering. This is handy if you need to check that a resulting
array matches your expectations when ordering is unimportant and not
necessarily deterministic. It can be used like so:

```ruby
expect([1,2,3]).to match_array([3,2,1])
```

This expectation is met, the test will pass.

# Construct A Constant From A String

Ruby's
[`Module.const_get`](http://ruby-doc.org/core-2.1.0/Module.html#method-i-const_get)
can be used to look for and retrieve the constant for a given name.

This can be used to construct a class name

```ruby
> Object.const_get("Math")
#=> Math
> Object.const_get("Math")::PI
#=> 3.141592653589793
```

It can also be used to reference a constant

```ruby
> Object.const_get("Math::PI")
#=> 3.141592653589793
```

You can even be more specific if you'd like

```ruby
> Math.const_get("PI")
#=> 3.141592653589793
```

Symbols are valid as well

```ruby
> Math.const_get(:PI)
#=> 3.141592653589793
```

# Convert A Unix Epoch Timestamp To A Time Object

Ruby's `Time` class has an [`#at`
method](https://ruby-doc.org/core-2.6.3/Time.html#method-c-at) that allows you
get the _time_ at a certain unix epoch timestamp. That timestamp is an integer
value representing the number of seconds since the unix epoch. While it is a
handy way to store that data, it is hard to tell what time it represents at a
glance.

```ruby
Time.at(1669652477)
=> 2022-11-28 10:21:17 -0600
```

Using `Time.at` we are able to turn that integer into a `Time` object that
represents the date and time in a human-readable way.

[source](https://prathamesh.tech/2020/03/02/converting-timestamps-to-ruby-objects/)

# Create an Array of Stringed Numbers

To create an array of numbers between `1` and `5`, I can do something like
the following:

```ruby
(1..5).to_a
> [1,2,3,4,5]
```

However, what if I want an array of `"1"` to `"5"`? That is, what if I want
an array of consecutive numbers as strings?

I can just reuse the above and map them to strings like so:

```ruby
(1..5).to_a.map(&:to_s)
> ['1','2','3','4','5']
```

Though, that seems more verbose than necessary. Ruby actually allows you to
do ranges of characters. Which means that I can modify my original approach
to look something like this:

```ruby
('1'..'5').to_a
> ['1','2','3','4','5']
```

# Create A CSV::Table Object

When you parse a file or string using `CSV.parse` (with `headers = true`) you
get a
[`CSV::Table`](https://ruby-doc.org/stdlib-2.5.1/libdoc/csv/rdoc/CSV/Table.html)
object in response. This object can be used to read what was in a file or it
can be used to create a new file. It is also handy as a potential test object
if you want to assume, but omit, file reading in a unit test.

You can create a `CSV::Table` one of the following two ways. First, with a file:

```ruby
require 'csv'

file = # read in file
csv_table = CSV.parse(file, headers: true)
```

Second, with a string, or even better, a HEREDOC:

```ruby
require 'csv'

csv_table =
  CSV.parse(<<-CSV, headers: true)
    first_name,last_name,taco
    Josh,Branchaud,"Al Pastor"
    Jake,Worth,Cauliflower
  CSV

csv_table.headers
#=> ["first_name", "last_name", "taco"]
```

From here, you can do what you need with it, whether that is using it in a test
or writing it to a file.

[source](https://ruby-doc.org/stdlib-2.6.3/libdoc/csv/rdoc/CSV.html#class-CSV-label-CSV+with+headers)

# Create A Hash From An Array Of Arrays

The `::[]` method on the `Hash` class allows you to succinctly create a hash
from an array of arrays -- or rather an array of tuples which are key value
pairs.

```ruby
> Hash[ [["a",2],["b",4]] ]
{"a"=>2, "b"=>4}
> Hash[ [[1,2],[3,4]] ]
{1=>2, 3=>4}
```

See the [`Hash::[]`
docs](http://ruby-doc.org/core-2.3.0/Hash.html#method-c-5B-5D) for more
details.

h/t Josh Davey

# Create Listing Of All Middleman Pages

Middleman is a handy tool for quickly throwing together a bunch of static
pages with layout and templating help at the ready. Once you have a handful
of pages up and running, you'll probably want a way to quickly navigate to
them. You can add a quick listing of all the pages with a couple helpers
provided by Middleman.

```erb
<ul>
  <% sitemap.resources.each do |resource| %>
    <li><%= link_to(resource.path, resource.path) %></li>
  <% end %>
</ul>
```

The `sitemap.resources` variable will contain a list of all the resources
that get processed and served by the Middleman app. The `link_to` helper
makes it easy to turn those into links.

Because `resources` includes images and other assets, you may want to filter
down to just `html` files which could look something like the following:

```erb
<ul>
  <% sitemap.resources
       .select { |resource| resource.path =~ /html$/ }
       .each do |resource|
  %>
    <li><%= link_to(resource.path, resource.path) %></li>
  <% end %>
</ul>
```

Just add the snippet to whatever page you'd like the page listing to appear
on.

# Create Named Structs With Struct.new

I often see `Struct` used to create some one-off anonymous data structure
like so:

```ruby
> person = Struct.new(:name, :age)
=> #<Class:0x007fc6c89112e8>
> person.new("Alice", 33)
=> #<struct name="Alice", age=33>
```

This will often get the job done, but on its own the resulting data
structure doesn't tell us as much as it could.

We can say more with a _named_ struct:

```ruby
Struct.new("Person", :name, :age)
=> Struct::Person
> Struct::Person.new("Bob", 24)
=> #<struct Struct::Person name="Bob", age=24>
```

When the first argument is a string that can be converted to a constant,
then we'll get a named struct that is subclassed under `Struct`.

We can also assign the struct initialization to a constant to do a similar
thing:

```ruby
> Person = Struct.new(:name, :age)
=> Person
> Person.new("Jerry", 45)
=> #<struct Person name="Jerry", age=45>
```

[source](https://ruby-doc.org/core-2.4.2/Struct.html#method-c-new)

# Create Thumbnail Image For A PDF

The [`rmagick`](https://rmagick.github.io/) gem is a wrapper around the
[ImageMagick](http://www.imagemagick.org/script/index.php) software suite.
This gem can be used to create a thumbnail image of a PDF using the
following snippet of code.

```ruby
require 'rmagick'
pdf = Magick::ImageList.new('document.pdf')
first_page = pdf.first
scaled_page = first_page.scale(300, 450)
scaled_page.write('document-thumbnail.jpg')
```

The scale can be adjust as necessary to the use case.

[source](http://stackoverflow.com/questions/65250/convert-a-doc-or-pdf-to-an-image-and-display-a-thumbnail-in-ruby)

# Defaulting To Frozen String Literals

> The cold never bothered me anyway.

The release of Ruby 2.2 introduced the ability to freeze string literals,
making them immutable. With the release of Ruby 2.3, strings can be frozen
by default without the use of `#freeze`. By adding the following magic
comment at the top of a file

```ruby
# frozen_string_literal: true
```

all string literals will default to frozen. That means that all string
literals in that file are immutable, cannot be modified. This gives the Ruby
interpreter some performance gains due to reduced object allocation.

This is the [issue](https://bugs.ruby-lang.org/issues/11473) that introduced
it.

# Define A Custom RSpec Matcher

You can define your own custom RSpec matchers. This is a great way to keep
your spec tight and readable. A custom, domain-specific matcher can convey
more intent in a single line than several lines of built-in matchers.

Here is a matcher to check if something is in a range:

```ruby
require 'rspec/expectations'

RSpec::Matchers.define :be_betwen do |lower, upper|
  match do |operand|
    expect(operand).to be >= lower
    expect(operand).to be <= upper
  end
end

describe MyThing do
  it "has a value between 0 and 10" do
    thing = MyThing.new

    expect(thing.value).to be_between(0, 10)
  end
end
```

By requiring `rspec/expectations` we are able to define a matcher that takes
0 or more arguments (in our case, `lower` and `upper`) and then make
assertions with them and the `expect` value.

[source](https://relishapp.com/rspec/rspec-expectations/v/2-4/docs/custom-matchers/define-matcher)

# Define A Method On A Struct

When defining a Ruby `Struct`, you can optionally pass it a block that defines
any number of methods as instance methods on that `Struct`. They can reference
the attributes of the `Struct`.

Here is an example of a person `Struct` with a `full_name` method that uses the
`first_name` and `last_name` attributes.

```ruby
Person = Struct.new(:first_name, :last_name, :age) do
  def full_name
    "#{first_name} #{last_name}"
  end
end
```

This `Struct` can be used like so:

```ruby
> liz = Person.new("Liz", "Lemon", 39)
=> #<struct Person first_name="Liz", last_name="Lemon", age=39>
> liz.full_name
=> "Liz Lemon"
```

This is a great way to make a `Struct` just a bit more powerful without having
to convert it into a full-blown PORO (plain old Ruby object).

# Destructure The First Item From An Array

In true Ruby fashion, there are plenty of idomatic ways to get the first
item from an array.

One of the ways is with assignment destructuring of the array.

It is common to see assignment destructuring with tuples:

```ruby
> name, email = ['Liz', 'liz.lemon@nbc.com']
=> ["Liz", "liz.lemon@nbc.com"]
> name
=> "Liz"
> email
=> "liz.lemon@nbc.com"
```

If you only want the first element, try this:

```ruby
> name, *rest = ['Liz', 'liz.lemon@nbc.com']
=> ["Liz", "liz.lemon@nbc.com"]
> name
=> "Liz"
> rest
=> ["liz.lemon@nbc.com"]
```

The first element is assigned to `name` and the remaining items in the array
are assigned to `rest`. That's because of the `*`.

I like to use this approach with an array-returning method.

```ruby
> def lookup_person(id)
    ['Liz', 'liz.lemon@nbc.com', id]
  end
=> :lookup_person
> name, *rest = lookup_person(22)
=> ["Liz", "liz.lemon@nbc.com", 22]
> name
=> "Liz"
irb(main):013:0> rest
=> ["liz.lemon@nbc.com", 22]
```

This method works as expected when dealing with an empty array.

```ruby
> name, *rest = []
=> []
> name
=> nil
> rest
=> []
```

In all of these, `, *rest` is important because otherwise the statement will be
a standard variable assignment.

# Destructuring Arrays In Blocks

If I am iterating over a collection of arrays (let's say tuples) and I want
to access the values of those arrays within the iteration block, I may do
something like the following:

```ruby
> a = [[1,2],[3,4],[5,6]]
> a.each { |tuple| puts "#{tuple[0]} - #{tuple[1]}" }
1 - 2
3 - 4
5 - 6
```

I can, however, use array destructuring which will not only simplify the
code, but also make it more readable, explicit, and intentional.

```ruby
> a = [[1,2],[3,4],[5,6]]
> a.each { |x_coord,y_coord| puts "#{x_coord} - #{y_coord}" }
1 - 2
3 - 4
5 - 6
```

In the same way, I can destructure arrays that are part of a hash like so:

```ruby
> h = {one: [1,2], two: [3,4], three: [5,6]}
> h.each { |key, (x_coord, y_coord)| puts "#{x_coord} - #{y_coord}" }
1 - 2
3 - 4
5 - 6
```

Note the parentheses that are placed around the part that is being
destructured. Without these parentheses, ruby will interpret `x_coord` as
the whole array value and `y_coord` will be `nil`.

# Disassemble Some Codes

The
[`RubyVM::InstructionSequence`](http://ruby-doc.org/core-2.2.0/RubyVM/InstructionSequence.html)
class makes it easy to compile, disassemble, and inspect bits of Ruby code.
We can quickly take a peek under the hood at a simple ruby statement, such
as `a = 1 + 2`, like so:

```ruby
> ruby_code = 'a = 1 + 2'
=> a = 1 + 2
> compiled_code = RubyVM::InstructionSequence.compile(ruby_code)
=> <RubyVM::InstructionSequence:<compiled>@<compiled>>
> puts compiled_code.disasm
== disasm: <RubyVM::InstructionSequence:<compiled>@<compiled>>==========
local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw:
-1@-1, kwrest: -1])
[ 2] a
0000 trace            1                                               (   1)
0002 putobject_OP_INT2FIX_O_1_C_
0003 putobject        2
0005 opt_plus         <callinfo!mid:+, argc:1, ARGS_SIMPLE>
0007 dup
0008 setlocal_OP__WC__0 2
0010 leave
=> nil
```

It is a bit archaic, but when we get to the line starting with `0002`, we
see values (`1` and then `2`) pushed onto the stack, then operated on, and
finally set on the local variable `a`. Fun!

# Double Splat To Merge Hashes

One way of merging two hashes is with `#merge`:

```ruby
> h1 = {a: 1, b: 2}
=> {:a=>1, :b=>2}
> h2 = {c: 3, d: 4}
=> {:c=>3, :d=>4}
> h1.merge(h2)
=> {:a=>1, :b=>2, :c=>3, :d=>4}
```

You can also use double splats for a slightly more concise approach:

```ruby
> h1 = {a: 1, b: 2}
=> {:a=>1, :b=>2}
> h2 = {c: 3, d: 4}
=> {:c=>3, :d=>4}
> {**h1, **h2}
=> {:a=>1, :b=>2, :c=>3, :d=>4}
```

This works particularly well when you want to expand an existing hash into a
hash you are creating on the fly:

```ruby
> h1 = {a: 1, b: 2}
=> {:a=>1, :b=>2}
> {c: 3, d: 4, **h1}
=> {:c=>3, :d=>4, :a=>1, :b=>2}
```

# Edit Previous Parts Of The Pry Buffer History

Each line of Ruby you enter into a Pry session is recorded with a number in
the buffer history. Pry keeps this buffer history so that you can recall
parts of it for editing and subsequent execution.

If you use the `edit` command by itself, Pry will open the previous Ruby
statement in your default editor. But what if you want to edit a statement
from a while back? Or even a series of statements?

Use the `--in` flag with `edit` either specifying a single record in the
buffer history or a range of records.

```ruby
$ pry
[1] pry(main)> puts "Hello"
Hello
=> nil
[2] pry(main)> puts "World"
World
=> nil
[3] pry(main)> puts "People"
People
=> nil
[4] pry(main)> edit --in 1..2
Hello
World
=> nil
```

# Editing Code In Pry

[Pry](http://pryrepl.org/) provides an enhanced REPL experience for Ruby.
One of the enhancements it provides is the ability to open your preferred
editor within a pry session. This makes it easy to compose and edit
multi-line blocks of code.

Try it out by typing `edit` within a pry session. Once you are ready, you
can save the file which will prompt pry to interpret the contents of your
file within the context of the pry session.

# Encode A String As URL-safe Base64

Ruby's standard lib comes with a [Base64
module](https://ruby-doc.org/stdlib-2.1.4/libdoc/base64/rdoc/Base64.html)
with a number of utilities for encoding and decoding data as
[Base64](https://en.wikipedia.org/wiki/Base64). One of the methods it
provides is `urlsafe_encode64`.

```ruby
> require 'base64'
true
> Base64.urlsafe_encode64('hello')
"aGVsbG8="
> Base64.urlsafe_encode64('1')
"MQ=="
```

You can pass it any string and it will create a URL-safe Base64 encoded
representation of that string.

# Enumerate A Pairing Of Every Two Sequential Items

From time to time, I've come across a situation where I want to iterate over a
list of items and have access to the item right after (or before depending on
how you want to think about it) the current item.

If I had a list like:

```ruby
items = [:a, :b, :c, :d, :z]
```

Then I'd love to turn it into a list of tuples like so:

```ruby
tuples = [[:a, :b], [:b, :c], [:c, :d], [:d, :z]]
```

I've finally come up with a one-liner I like for turning `items` into `tuples`.

```ruby
items.first(items.size - 1)
# => [:a, :b, :c, :d]
items.last(items.size - 1)
#=> [:b, :c, :d, :z]
items.first(items.size - 1).zip(items.last(items.size - 1))
#=> [[:a, :b], [:b, :c], [:c, :d], [:d, :z]]
```

I realized that if I take everything but the last item (using `first`) and take
everything but the first item (using `last`), then I can `zip` those two arrays
together into the list of tuples I was looking for.

# Evaluating One-Off Commands

When I need to quickly test something out in Ruby, I will often reach for
`irb`. However, there is an even quicker way to send a line of code to
ruby for evaluation. Use the `ruby` binary with the `-e` flag followed
by your line of ruby. For instance,

```
$ ruby -e 'puts Class.ancestors'
[Class, Module, Object, Kernel, BasicObject]
```

# Exclude Values From An Array

In true Ruby fashion, there are all sorts of ways to exclude values from an
array.

If you just want to exclude `nil` values, you can use
[`#compact`](https://ruby-doc.org/core-3.0.0/Array.html#method-i-compact).

```ruby
> [1,nil,:what,4].compact
#=> [1, :what, 4]
```

If you want to exclude `nil` values and some other named value, you could use
[`#filter`](https://ruby-doc.org/core-3.0.0/Array.html#method-i-filter) or
[`#reject`](https://ruby-doc.org/core-3.0.0/Array.html#method-i-reject).

```ruby
> [1,nil,:what,4].filter { |val| !val.nil? && val != :what }
#=> [1, 4]
> [1,nil,:what,4].reject { |val| val.nil? || val == :what }
#=> [1, 4]
```

The filter is clumsy and heavy-handed for this sort of example. A really terse
way of doing the same thing is with set difference:
[`#-`](https://ruby-doc.org/core-3.0.0/Array.html#method-i-2D).

```ruby
> [1,nil,:what,nil,5] - [:what,nil]
#=> [1, 5]
```

Or the spelled out
[`#difference`](https://ruby-doc.org/core-3.0.0/Array.html#method-i-difference)
method.

```ruby
> [1,nil,:what,nil,5].difference([:what,nil])
#=> [1, 5]
```

# Expect A Method To Be Called And Actually Call It

You can assert that a method is called without actually executing it. This is
often what `expect(...).to receive(:method_name)`  is used for. If you do want
that method called, RSpec can accommodate you.

Let's say we have the following two classes:

```ruby
class Greeting
  def self.say_hello
    raise "Don't actually execute this"
    puts "Hello"
  end
end

class GreetingService
  def self.run
    Greeting.say_hello
  end
end
```

We can assert that `say_hello` gets called without actually raising the
exception (first `it` block). If we tack on `and_call_original` then RSpec will
make the assertion and execute the method (second `it` block).

```ruby
describe "expect and call original" do
  it "expect the message is received" do
    expect(Greeting).to receive(:say_hello)
    GreetingService.run
    # passes
  end

  it "expect and call original" do
    expect(Greeting).to receive(:say_hello).and_call_original
    GreetingService.run
    # fails, RuntimeError
  end
end
```

[source](https://relishapp.com/rspec/rspec-mocks/v/2-14/docs/message-expectations/calling-the-original-method)

# Extract A Column Of Data From A CSV File

Let's say I have just downloaded a medium-sized CSV of data onto my hard drive.
I want to exact one column of data from that CSV to inject into some other
tool/process.

Here is how I'd go about doing that with Ruby.

```ruby
require 'csv'

filename = "#{Dir.home}/Downloads/file.csv"
column_index = 2 # zero-indexed column of interest

# an array of collecting the values I want to extract
col_data = []

# read in the CSV into memory
csv_data = CSV.read(filename)

# pop headers out of the top of the array
csv_data.shift

# grab the column of interest from each row
csv_data.each { |row| col_data << row[column_index] }

# do something with the extract column of data
comma_separated_list = col_data.join(', ')
system "command -v pbcopy >/dev/null 2>&1 && echo '#{comma_separated_list}' | pbcopy"
```

All but the last two lines are pretty standard. We identify the file and column
of interest. Read in the CSV from that file and ditch the headers. Then we grab
that column's value for every entry in the CSV.

Then we need to do something with that data.

In my case, I want to turn those values into a comma-separated list and put it
on my clipboard. Those last two lines do just that.

# FactoryGirl Sequences

[FactoryGirl sequences](https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md#sequences)
are often used inline for unique values such as emails:

```ruby
factory :user do
  sequence(:email) { |n| "person#{n}@example.com" }
end
```

However, a sequence can be defined on its own

```ruby
FactoryGirl.define do
  sequence :email do |n|
    "person#{n}@example.com"
  end
end
```

That means it can be invoked outside the context of a factory

```ruby
> FactoryGirl.generate :email
=> "person1@example.com"
> FactoryGirl.generate :email
=> "person2@example.com"
```

Or it can be used as a shared sequence across multiple factories

```ruby
factory :customer do
  ...
  email
end

factory :admin do
  ...
  email
end
```

# Fail

The `fail` method is synonymous with `raise` in Ruby. Consider the following
code snippet:

```ruby
def is_odd?(num)
  num.odd?
rescue
  fail StandardError, 'you cannot use odd on this'
end

> is_odd?(1)
#=> true
> is_odd?('hello')
#=> StandardError: you cannot use odd on this
```

Nevertheless, I believe the `raise` method is preferred to the `fail`
method.

[source](http://ruby-doc.org/core-2.3.0/Kernel.html#method-i-fail)

h/t Dorian Karter

# Find The Min And Max With A Single Call

Ruby's Enumerable comes with the `#min` and `#max` methods for finding,
respectively, the minimum and maximum value in the target collection.

If you wanted to find both the min and the max of the same collection, you
could call them one after another.

```ruby
list = [3,7,4,15,9,1,2]

list.min
#=> 1
list.max
#=> 15
```

Ruby's Enumerable also supports a slightly more efficient way -- it finds both
at the same time when you call
[`#minmax`](https://apidock.com/ruby/Enumerable/minmax).

```ruby
list = [3,7,4,15,9,1,2]
#=> [1,15]
```

# Finding The Source of Ruby Methods

Ruby's [`Method`](http://ruby-doc.org/core-1.9.3/Method.html) class
includes a feature that can help you quickly find the location of
source code files where a particular method is defined. The method is aptly
named [`source_location`](http://ruby-doc.org/core-1.9.3/Method.html#method-i-source_location).

When debugging a project that is using the
[Treat](https://github.com/louismullie/treat) gem, you can take a source dive
by first finding the relevant source files. For instance, if you want to look
into the word creation functionality, you might go through an exploratory
process like the following:

```ruby
> require 'Treat'
=> true
> Treat::Entities::Word.build('stuff')
=> Word (70331843958460)  --- "stuff"  ---  {}   --- []
> Treat::Entities::Word.method(:build)
=> #<Method: Class(Treat::Entities::Entity::Buildable)#build>
> Treat::Entities::Word.method(:build).source_location
=> ["/Users/jbranchaud/.gem/ruby/2.1.4/gems/treat-2.1.0/lib/treat/entities/entity/buildable.rb", 29]
```

You can now take a closer look at the implementation of the `build` method.

The main caveat to this process is that it can only find source locations
for methods defined in ruby land. Calling `source_location` on any method
defined in C code will result in `nil`.

# Generate A Signed JWT Token

The [`jwt`](https://github.com/jwt/ruby-jwt) gem is a Ruby library for
encoding and decoding JWT tokens. You can create a signed JWT with the
`#encode` method by specifying a secret and a hash algorithm.

```ruby
payload = { id: 1, email: 'user@example.com' }
secret = Rails.application.credentials.secret_key_base

token = JWT.encode(payload, secret, 'HS256')
```

This will create a JWT token that contains some JWT headers, application
data, and an encrypted secret that signs the data. This can be passed to and
from your client app as a way of identifying and authenticating a user.

See the [`jwt-ruby` docs](https://github.com/jwt/ruby-jwt) or
[jwt.io](https://jwt.io/) for more details.

# Generate Ruby Version And Gemset Files With RVM

[RVM](https://rvm.io), the ruby version manager, is a fairly flexible tool
that supports a number of workflows. The `rvm` utility can be used to
generate both a `.ruby-version` file and a `.ruby-gemset` file for a given
project.

```bash
$ rvm --ruby-version use 2.5.3@my_project
```

This will generate a `.ruby-version` file in your current project directory
that points RVM to the `2.5.3` version of Ruby. It will also create a
`.ruby-gemset` file that RVM will use for managing this project's gemset.

# Get Info About Your Ruby Gems Environment

Want to know what Ruby version is being used? Or into what directory gems are
being installed?

```bash
$ gem environment
```

This command will answer those questions and give you a whole host of other
information about your RubyGems environment.

There are more details in their
[documentation](https://guides.rubygems.org/command-reference/#gem-environment).

# Identify Outdated Gems

Bundler can be used to identify outdated gems for a given project. By
running `bundle outdated` in a project's directory, Bundler will compare the
versions of all stated gem dependencies against the gem server and report a
list of those gems that are not up to date.

See the [Bundler docs](http://bundler.io/v1.1/bundle_outdated.html) for more
details.

# If You Detect None

The
[`Enumerable#detect`](http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-detect)
method, which is synonymous with `#find`, can be given an optional argument,
`ifnone`, that is called when nothing in the array meets the conditional in
the block. Though I am not sure how this is practically useful and cannot
find an example of it in use, this contrived example illustrates how it
works.

```ruby
# without the fallback behavior
> [2,4,6,8].detect { |x| x.odd? }
=> nil

# with a proc as an argument
> [2,4,6,8].detect(->{0}) { |x| x.odd? }
=> 0
```

The last example can also be written as:

```ruby
> [2,4,6,8].detect(->{0}, &:odd?)
=> 0
```

And if you want to be really explicit:

```ruby
> [2,4,6,8].detect(ifnone=->{0}, &:odd?)
=> 0
```

# Iterate With An Offset Index

You can iterate over a collection of items with the
[`#each`](https://devdocs.io/ruby~2.5/enumerator#method-i-each) method. If you
want to know the index of each item as you go, you can use the
[`#each_with_index`](https://devdocs.io/ruby~2.5/enumerable#method-i-each_with_index)
variant.

```ruby
> ["one", "two", "three"].each_with_index do |item, index|
    puts "#{item} - #{index}"
  end
one - 0
two - 1
three - 2
=> ["one", "two", "three"]
```

The initial index will always be `0` when using `#each_with_index`.

What about if you want the index value to be offset by some number?

You can use the
[`#with_index`](https://devdocs.io/ruby~2.5/enumerator#method-i-with_index)
method on an _enumerator_. It optionally takes an `offset` argument.

```ruby
> ["one", "two", "three"].each.with_index(1) do |item, index|
    puts "#{item} - #{index}"
  end
one - 1
two - 2
three - 3
=> ["one", "two", "three"]
```

# Include Extra Context In A Honeybadger Notify

The simplest way to `notify` [Honeybadger](https://www.honeybadger.io/) of an
error is to either pass it the exception directly:

```ruby
rescue SpecializedError => e
  Honeybadger.notify(e)
end
```

Or to give it a custom message:

```ruby
Honeybadger.notify("The user #{user.id} was unable to access their account.")
```

Honeybadger collects a lot of additional context about the report based on
where it is called. More context is usually better though. You can pass
additional, specific context with the `context` keyword argument.

```ruby
message = "The user was unable to access their account."
Honeybadger.notify(
  message,
  context: { user_id: user.id, query: params[:query] }
)
```

Include whatever else you might want to know and those values will show up in
the Honeybadger web interface.

[source](https://docs.honeybadger.io/lib/ruby/getting-started/reporting-errors/)

# Ins And Outs Of Pry

When executing commands during a [Pry](http://pryrepl.org/) session, you'll
see an incrementing number for each prompt as you enter each statement.
These numbers can be used to look up the inputs and outputs of each
statement executed during the session. The statements and their results are
made available in the array-like `_in_` and `_out_` objects.

```ruby
[1] pry(main)> :one
=> :one
[2] pry(main)> 1 + 1
=> 2
[3] pry(main)> ["t", "h", "r", "e", "e"].join
=> "three"
[4] pry(main)> _in_.to_a
=> [nil, ":one\n", "1 + 1\n", "[\"t\", \"h\", \"r\", \"e\", \"e\"].join\n"]
[5] pry(main)> _out_.to_a
=> [nil, :one, 2, "three", [nil, ":one\n", "1 + 1\n", "[\"t\", \"h\", \"r\", \"e\", \"e\"].join\n"]]
[6] pry(main)> _out_[2]
=> 2
[7] pry(main)> _in_[2]
=> "1 + 1\n"
```

[source](https://github.com/pry/pry/wiki/Special-Locals#In_and_out)

# Invoking Rake Tasks Multiple Times

I have a rake task, `build`, that builds a single record for development
purposes. I want a supplemental rake task, `build:all`, that builds a bunch
of different records. To keep things dry, `build:all` should just invoke
`build` a number of times.

```ruby
namespace :build do
  task :all do
    predefined_list.each do |data|
      Rake::Task["build"].invoke(data)
    end
  end
end
```

This doesn't work though. No matter how many items are in the list, the
`build` task only seems to get run once. This is because by default tasks
can only be invoked once in a given context. To get around this, the task
needs to be _reenabled_ after each invocation.

```ruby
namespace :build do
  task :all do
    predefined_list.each do |data|
      Rake::Task["build"].invoke(data)
      Rake::Task["build"].reenable
    end
  end
end
```

# IRB Has Built-In Benchmarking With Ruby 3

As of Ruby 3.0.0, `irb`—Ruby's interactive console—comes with a `measure`
method. This can be used to turn the processing time feature on and off. With
it on, you can do rough benchmarking of how long different process take.

Ruby `measure` or `measure(true)` to turn on the timing feature.

```ruby
> measure
TIME is added.
=> nil
```

Once it is enabled, any command you run will including processing time details:

```ruby
> array = [1,2,3,4]
processing time: 0.000033s
=> [1, 2, 3, 4]
> array.zip(array).map { |a,b| a * b ** (a * b) }
processing time: 0.000057s
=> [1, 32, 59049, 17179869184]
```

[source](https://jemma.dev/blog/irb-measure)

# Jump Out Of A Nested Context With Throw/Catch

Ruby's `throw/catch` construct, not to be confused with its `raise/rescue`
exception handling syntax, allows you to jump out of a nested context. This is
similar to [loop
labels](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)
in other languages.

For example, in my recent [Advent of Code
solution](https://www.youtube.com/watch?v=Hvp07gTQhF4), I was able to employ
this construct. Once within a doubly-nested loop, I can `throw` when I find the
answer I'm looking for to both break out of the loop and return an value.

```ruby
answer =
  catch do |obj|
    input.each_with_index do |input1, x|
      input.each_with_index do |input2, y|
        next unless x != y

        next unless input1 + input2 == 2020

        throw(obj, input1 * input2)
      end
    end

    raise StandardError, 'No answer found'
  end

puts answer
```

If I were to never reach the `throw` before exhausting the doubly-nested loop,
then the catch would product whatever value is returned within the block. In
this case, I raise an error because it'd be exceptional for the `throw` to
never be reached.

[source](https://apidock.com/ruby/Kernel/catch)

# Last Raised Exception In The Call Stack

In Ruby, the `$!` global variable contains the last exception that was
raised in the current call stack. This makes it trivial to check what error
is being rescued even if it hasn't been captured in a local variable.

```ruby
class MyError < StandardError; end

def do_stuff
  raise MyError
rescue
  puts "rescuing #{$!}"
end

do_stuff
#=> rescuing MyError
```

# Limit Split

I've only ever used Ruby's
[`String#split`](http://ruby-doc.org//core-2.2.0/String.html#method-i-split)
with the delimiter argument (e.g. `"this string has spaces".split(" ")`).
However, this method has another argument you can specify; the `limit`
argument. With `limit`, you can *limit* the number of times that the split
happens.

```ruby
"this string has many spaces".split(" ")
# => ["this", "string", "has", "many", "spaces"]
"this string has many spaces".split(" ", 3)
# => ["this", "string", "has many spaces"]
```

There are surely many use cases, but one that stands out (from [The Rails 4
Way](https://leanpub.com/tr4w)) is for splitting a name into *first* and
*last* names.

```ruby
"Josh Branchaud".split(" ", 2)
# => ["Josh", "Branchaud"]
"David Heinemeier Hansson".split(" ", 2)
# => ["David", "Heinemeier Hansson"]
```

This really simplifies the code that is needed to make the following example
work:

```ruby
def create_user(name)
  user = User.new
  user.first_name, user.last_name = name.split(" ", 2)
  user.save
end
```

# List The Running Ruby Version

The running Ruby version can be listed with the `RUBY_VERSION` constant.

For instance, if my Ruby version is 3.0.0, then I could get the version like
so:

```ruby
> RUBY_VERSION
=> "3.0.0"
```

This is nice if you just want to check in an IRB session or if you need it as
part of a script.

[source](https://blog.arkency.com/which-ruby-version-am-i-using-how-to-check/)

# Listing Local Variables

In Ruby 2.2, the `binding` object gives us access to a method
`#local_variables` which returns the symbol names of the binding's local
variables. We can see this in action with

```ruby
def square(x)
  puts binding.local_variables.inspect
  x.times do |a|
    puts binding.local_variables.inspect
  end
  z = x * x
  puts binding.local_variables.inspect
  z
end
square(2)
```

which results in

```ruby
[:x, :z]
[:a, :x, :z]
[:a, :x, :z]
[:x, :z]
=> 4
```

[source](http://ruby-doc.org/core-2.2.0/Binding.html#method-i-local_variables)

# Map With Index Over An Array

The [`#map`](https://devdocs.io/ruby~2.5/enumerable#method-i-map) method on its
own allows you to interact with each item of an array, producing a new array.

```ruby
[1,2,3].map { |item| item * item }
#=> [1,4,9]
```

If you also want access to the index of the item, you'll need some help from
other enumerable methods. As of Ruby 1.9.3, you can chain on
[`#with_index`](https://devdocs.io/ruby~2.5/enumerator#method-i-with_index):

```ruby
[1,2,3].map.with_index { |item, index| item * index }
#=> [0,2,6]
```

This method has the added benefit of allowing you to specify the starting value
of the index. It normally starts with `0`, but you could just as easily start
at `1`:

```ruby
[1,2,3].map.with_index(1) { |item, index| item * index }
#=> [1,4,9]
```

[source](https://stackoverflow.com/a/11280903/535590)

# Mock Method Chain Calls With RSpec

Generally with RSpec you mock one method call at a time:

```ruby
allow(User).to receive(:new).and_return(true)
```

Sometimes you are dealing with code that involves a chain of method calls.

```ruby
User
  .new
  .approve
  .send_welcome_email
```

If it becomes unreasonable to mock out each individual method, you can instead
mock out the chain of calls.

```ruby
allow(User).to receive_message_chain('new.approve.send_welcome_email')
```

Alternatively, you can write this as:

```ruby
allow(User).to receive_message_chain(:new, :approve, :send_welcome_email)
```

[source](https://relishapp.com/rspec/rspec-mocks/docs/working-with-legacy-code/message-chains)

# Mocking Requests With Partial URIs Using Regex

Generally when mocking out requests with the
[webmock](https://github.com/bblimke/webmock) gem, we specify full request
URIs like so:

```ruby
stub_request(:post, 'http://localhost:4000/api/posts')
```

We may not want to specify the entire URI though. For instance, the host may
change or be configurable. The `stub_request` method allows us to use regex.

```ruby
stub_request(:post, %r|/api/posts|)
```

Using [the `%r` regex literal
syntax](https://ruby-doc.org/core-2.2.0/Regexp.html), we are able to avoid
escaping all of the `/` characters in our URI.

h/t Brian Dunn

# Named Regex Captures Are Assigned To Variables

Both `String` and `Regexp` include the `=~` operator as a way of checking if a
string and a regex match.

When the `Regexp` version of
[`=~`](https://ruby-doc.org/core-2.5.1/Regexp.html#method-i-3D~) with named
capture groups, those named captures will be auto-assigned as local variables.

Here is a regex that includes a named capture: `(?<id>\d+)`. The parentheses
define the capture area and the `?<id>` specifies that whatever follows in the
capture will be named `id`.

```
/Tile: (?<id>\d+)/ =~ 'Tile: 1234'
#=> 0
id
=> "1234"
```

After the match operator (`=~`) runs in the first line, the local variable `id`
gets assigned to whatever it matches in the corresponding string.

[source](https://ruby-doc.org/core-2.5.1/Regexp.html#class-Regexp-label-Capturing)

# Navigate Back In The Browser With Capybara

There are two ways to navigate back to a previous page. Capybara is driving
the browser and it can be instructed to go back using its built-in command
or by executing some JavaScript.

```ruby
page.go_back
```

or

```ruby
page.evaluate_script('window.history.back()')
```

# Next And Previous Floats

The `Float` class has two interesting methods for stepping forward or
backwards through the numbers that can actually be *represented* by floats.
This is handy since floats are not evenly spaced.

Use `#next_float` to go forward

```ruby
> 2.0
=> 2.0
> _.next_float
=> 2.0000000000000004
> _.next_float
=> 2.000000000000001
> _.next_float
=> 2.0000000000000013
> _.next_float
=> 2.0000000000000018
```

Use `#prev_float` to go backwards

```ruby
> 2.0
=> 2.0
> _.prev_float
=> 1.9999999999999998
> _.prev_float
=> 1.9999999999999996
> _.prev_float
=> 1.9999999999999993
> _.prev_float
=> 1.9999999999999991
```

I cannot think of any practical use cases, but it is fun to know they are
there if you need them.

# Or Operator Precedence

What's the difference between `||` and `or` in Ruby?

Let's look at an example to find out. First, let's start with some boolean
variables:

```ruby
> a, b = false, true
=> [false, true]
```

Now, let's try the different _or_ operators:

```ruby
> a || b
=> true
> a or b
=> true
```

Cool, they seem to work as expected.

Finally, let's capture the result in a variable:

```ruby
> c = a or b
=> true
> c
=> false
```

But why is `c` false and not true? Operator precedence. The assignment
operator (`=`) takes precedence over the `or` operator causing `c` to be
assigned to the value of `a` (`false`) before `or`'d with `b`.

[source](http://stackoverflow.com/questions/2083112/difference-between-or-and-in-ruby)

# Override The Initial Sequence Value

[FactoryGirl sequences](https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md#sequences)
can be defined with an initial starting value

```ruby
FactoryGirl.define do
  sequence :email, 1000 do |n|
    "person#{n}@example.com"
  end
end
```

thus:

```ruby
> FactoryGirl.generate :email
=> "person1000@example.com"
> FactoryGirl.generate :email
=> "person1001@example.com"
```

# Parallel Bundle Install

The `bundle install` command can take quite a while sometimes. This is
especially true for when you are setting up a fresh dev environment for an
existing project. Fortunately, Bundler provides a flag for parallelizing
the gem installs and Bundler is smart enough that it knows how to resolve
the dependencies so that this is possible in the first place. Just tell
Bundler how many concurrent jobs you want it to install with (4 is a good
number) and let it do the rest of the work.

```bash
$ bundle install --jobs 4
```

# Parse JSON Into An OpenStruct

The `json` module that ships with Ruby is something I use a lot in web app
APIs. When a request comes in as a string of JSON, I use `JSON.parse` to turn
it into a hash. That's because a hash is much easier to work with than a string
representation of some JSON data.

```ruby
> require 'json'
=> true
> data = JSON.parse('{"name": "Josh", "city": "Chicago"}')
=> {"name"=>"Josh", "city"=>"Chicago"}
> data["name"]
=> "Josh"
```

The hash access syntax can sometimes get to be clunky. `JSON.parse` is flexible
enough that it can do more than turn a JSON string into a hash. It can turn it
into any object that plays along. `OpenStruct` is a great example of this.

To tell `JSON.parse` to use a class other than `Hash`, include [the
`object_class`
option](https://ruby-doc.org/stdlib-3.0.1/libdoc/json/rdoc/JSON.html#module-JSON-label-Parsing+Options).

```ruby
> json_str = '{"name": "Josh", "city": "Chicago"}'
=> "{\"name\": \"Josh\", \"city\": \"Chicago\"}"
> data = JSON.parse(json_str, object_class: OpenStruct)
=> #<OpenStruct name="Josh", city="Chicago">
> data.name
=> "Josh"
```

Because of how `OpenStruct` objects work, we can use method notation to access
the fields parsed from the JSON string.

[source](https://stackoverflow.com/a/48396425/535590)

# Parsing A CSV With Quotes In The Data

If a CSV contains unescaped quote characters--like you might find in a CSV full
of measurement data--then Ruby's
[CSV](https://ruby-doc.org/stdlib-2.6.1/libdoc/csv/rdoc/CSV.html) library will
be unable to parse it.

Here is what happens with a line of CSV about some lumber:

```ruby
> require 'csv'
> CSV.parse_line('oak,2",4"')
CSV::MalformedCSVError (Illegal quoting in line 1.)
```

However, we can enable some more lenient, liberal parsing of the data with the
`liberal_parsing` argument.

```ruby
> require 'csv'
> CSV.parse_line('oak,2",4"', liberal_parsing: true)
=> ["oak", "2\"", "4\""]
```

[source](https://blog.bigbinary.com/2016/11/22/ruby-2-4-introduces-liberal_parsing-option-for-parsing-bad-csv-data.html)

# Pass A Block To Count

Ruby's [`Enumerable`](http://ruby-doc.org/core-2.2.3/Enumerable.html) module
comes with the method `#count` for determining how many items are in an
array or hash.

```ruby
> [1,2,3].count
=> 3
> {a: 1, b: 2}.count
=> 2
```

The `#count` method has a trick up its sleeve though. It can take a block
with a predicate that returns `true` or `false`. It essentially acts like
`#select` returning the count rather than the array subset itself.

```ruby
> [1,2,3].count { |x| x.odd? }
=> 2
> {a: 1, b: 2}.count { |(x,y)| y < 0 }
=> 0
```

# Passing Arbitrary Methods As Blocks

Use
[`Object#method`](http://ruby-doc.org/core-1.8.7/Object.html#method-i-method)
to create a callable `Method` object that can be passed to methods
that yield to a block.

```ruby
def inc(x)
  x + 1
end

[1,2,3].map(&method(:inc))
#=> [2,3,4]
```

# Passing Arguments To A Rake Task

You can create a rake task that takes arguments by including an array of
named arguments in the task declaration.

```ruby
task :greeting, [:name] do |task, args|
  puts "Hello, #{args.name}!"
end
```

You can then pass an argument to that task when invoking it.

```bash
$ rake greeting[World]
Hello, World!
```

[source](http://davidlesches.com/blog/passing-arguments-to-a-rails-rake-task)

# Pattern Match Values From A Hash

As of Ruby 3.0.0, the _rightward assignment_ operator (`=>`) was introduced as
another syntax for assigning values to variables. With it comes an experimental
pattern matching capability. This pattern matching can be used with hashes to
extract keyed values into local variables.

Pattern matching with rightward assignment can be done by placing a hash on the
left-hand side of the `=>` operator and then placing a hash-like listing of
keys to be matched against.

```ruby
> some_hash = { name: "Josh", handle: "@jbrancha", age: :unknown }
=> {:name=>"Josh", :handle=>"@jbrancha", :age=>:unknown}
> some_hash => {name:, handle:}
(irb):3: warning: One-line pattern matching is experimental, and the behavior may change in future versions of Ruby!
=> nil
> name
=> "Josh"
> handle
=> "@jbrancha"
```

This example extracts `name` and `handle` as local variables assigned with the
values of the those keys from the hash.

Note that this feature is _experimental_.

Also note that referencing a key that doesn't exist in a pattern matching
statement will raise a `NoMatchingPatternError`.

[source](https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/)

# Percent Notation

Ruby has many uses for the `%` character. One of the more obscure uses is as
a notion for custom delimited strings. Use the percent notation with a
non-alphanumeric character to surround a string.

```ruby
> %=Jurassic Park=
=> "Jurassic Park"
> % Ghostbusters 
=> "Ghostbusters"
```

It even works with balanced characters

```ruby
> %(The Goonies)
=> "The Goonies"
```

This is useful for defining a string that has both types of quotes

```ruby
> %[That'll be the "day"]
=> "That'll be the \"day\""
```

It's also useful for creating horribly obfuscated code

```ruby
> %=what===%?what?
=> true
```

h/t [Josh Davey](https://twitter.com/joshuadavey/status/615613617099046912)

# Question Mark Operator

Ruby has a question mark (`?`) operator that works like so

```ruby
> ?a
=> "a"
> ?\s
=> " "
> ??
=> "?"
> ?a + ?b + ?c
=> "abc"
```

It essentially creates single character strings. At least in Ruby 1.9+ it
does. In versions of Ruby before 1.9, the `?` operator could be used to get
the ascii character code of the operand character.

h/t Josh Davey

[source](http://stackoverflow.com/questions/16641205/what-does-the-question-mark-operator-do)

# Rake Only Lists Tasks With Descriptions

Rake describes the `-T` flag as

> Display the tasks (matching optional PATTERN) with descriptions, then exit.

And `rake -T` does just exactly that. It lists all the tasks with
descriptions. Any rake task that you define without a `desc` will not be
included.

Consider the following rake task definitions

```ruby
desc 'foobar does this and that'
task :foobar do
  puts 'this and that'
end

task :foobaz do
  puts 'not so much'
end
```

This is what I get when listing the rake tasks filtered by _foo_

```bash
$ rake -T foo
rake foobar  # foobar does this and that
```

The `foobar` task (which has a description) is listed, but `foobaz` is not.

A hack of sorts to get around this is to use the `-P` flag which will end up
listing all tasks even if they do not have a description (`rake -P | grep
'foo'`).

# Read The First Line From A File

If I wanted to read the first line from a file with Ruby, I'd probably read the
whole thing in, split it by newlines, and grab the first.

```ruby
File.read('README.md').split(/\n/).first
```

This is inefficient in that it reads in the entire file. For small files this
won't matter, but for larger files it could become a bottleneck.

There is a method of doing this that is just as concise and streams the first
part of the file rather than reading it in its entirety. The `File.open` method
takes a block. This means you can pass a symbol-to-proc to it as the block
argument.

```ruby
> File.open('README.md', &:readline).strip
=> "# TIL"
> File.open('README.md', &:gets).strip
=> "# TIL"
```

Both `#readline` and `#gets` will grab the first line including the newline
character (hence the `#strip`). The only difference is that `#readline` will
raise an exception if the file is empty.

These methods both come from the `IO` module and [stream the file rather than
slurping the whole thing
in](https://blog.appsignal.com/2018/07/10/ruby-magic-slurping-and-streaming-files.html).

[source](https://stackoverflow.com/questions/1490138/reading-the-first-line-of-a-file-in-ruby)

# Rendering ERB

If you have a string that contains ERB templating, you can quickly generate
the resulting string with the following code snippet:

```ruby
require 'erb'

some_template_string = <<-TEXT
The top
<% 5.times do |i| %>
Item <%= i + 1 %>
<% end %>
The bottom
TEXT

puts ERB.new(some_template_string).result
```

This will print the following to stdout:

```
The top
Item 1
Item 2
Item 3
Item 4
Item 5
The bottom
```

[source](http://www.stuartellis.eu/articles/erb/)

# Replace The Current Process With An External Command

Ruby's
[`Kernel#exec`](http://ruby-doc.org/core-2.2.3/Kernel.html#method-i-exec)
method can be used to run an external command. What differentiates it from
executing commands with the likes of back ticks or `%x[]` is that instead of
forking a child process, it replaces the current process.

For instance, the following ruby script, when executed, will replace itself
with an `irb` session.

```ruby
Kernel.exec('irb')
```

The external command will even benefit from the existing environment. For
example, if I set the following environment variable

```bash
$ export GREETING=hello
```

and then execute a file containing

```ruby
Kernel.exec('echo $GREETING')
```

I can expect to see `hello` printed to stdout.

# Require Entire Gemfile In Pry Session

Want to experiment in a pry session with some of the gems in your project's
`Gemfile`? You can quickly require all the gems for your project using
Bundler's `#require` method.

Just require `bundler` itself and then execute `Bundler.require`. Everything
will be loaded in.

```ruby
> require 'bundler'
=> true
> Bundler.require
=> [Gem::Dependency.new("devise", Gem::Requirement.new([">= 0"]), :runtime),
 Gem::Dependency.new("rails", Gem::Requirement.new(["= 4.2.5"]), :runtime),
 Gem::Dependency.new("pg", Gem::Requirement.new(["~> 0.15"]), :runtime),
...
```

# Rerun Only Failures With RSpec

After running a big test suite, I may have a bunch of output on the screen
including the results of a couple test failures. I like to bring the context
of the test failures front and center and make sure they are consistent test
failures (not flickering failures). Instead of copying and pasting each
failure, I can rerun `rspec` in a way that executes only the test cases that
failed.

```
$ rspec --only-failures
```

This feature requires that you set a file for RSpec to persist some state
between runs. Do this in the `spec/spec_helper.rb` file. For example:

```ruby
RSpec.configure do |config|
  config.example_status_persistence_file_path = "spec/examples.txt"
end
```

See more details
[here](https://relishapp.com/rspec/rspec-core/docs/command-line/only-failures).

h/t Brian Dunn

# Retry A Block After An Exception

Ruby comes with a [_retry_
mechanism](https://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-retry)
that allows you to recover from known exceptions by retrying the code that led
to the exception. In network or timing-based situations where race conditions
are possible, the most straightforward recourse may be to just _retry_ a couple
times.

Set up a `begin` / `rescue` block like you'd normally do for a chunk of code
that may raise an exception. Then add a `retry` call to the `rescue` block.

```ruby
begin
  puts "About to do a thing (#{retries})"

  raise StandardError if rand(5) != 4

  puts "Success!"
rescue StandardError => e
  retry
end
```

If an exception is raised, this will tell Ruby to re-execute the code in the
`begin` block over and over until the exception isn't raised.

To avoid an infinite loop, you can limit the retries with a counting variable.

```ruby
begin
  retries ||= 0
  puts "About to do a thing (#{retries})"

  raise StandardError if rand(5) != 4

  puts "Success!"
rescue StandardError => e
  retry if (retries += 1) < 3

  # all retries failed, re-raise exception
  raise e
end
```

This will re-raise after 3 tries.

Here is the [full example](https://gist.github.com/jbranchaud/629fb3b9d55c817e5c9fc480790dfabc)

[source](https://www.honeybadger.io/blog/how-to-try-again-when-exceptions-happen-in-ruby/)

# Returning With Sequel

The [`sequel`](https://github.com/jeremyevans/sequel) gem is a database
toolkit that allows you to interact with most databases. PostgreSQL has
support for composite primary keys, but `sequel`, which is supposed to return
the `id` of newly inserted records, isn't sure what to return when faced
with a composite primary key. You can get around this by telling `sequel`
exactly what should be returned using the `#returning` method. For instance,
get it to return just the `id` of the new record:

```ruby
DB[:floors].returning(:id).insert(hotel_id: 4, id: 1, ...)
# [{id: 1}]
```

To get it to return both parts of composite key:

```ruby
DB[:floors].returning(:id, :hotel_id).insert(hotel_id: 4, id: 1, ...)
# [{id: 1, hotel_id: 4}]
```

# rexml Is A Bundled Gem As Of Ruby 3.0.0

Are you seeing an error loading certain
[`rexml`](https://github.com/ruby/rexml) files?

```
LoadError: cannot load such file -- rexml/document
```

It may be that `rexml` no longer ships as part of the Ruby version you are
using. If you are working with Ruby 3.0.0 or later, the `rexml` gem needs to be
explicitly installed as it is now a bundled gem.

Either add it to your `Gemfile`:

```
gem 'rexml'
```

or install it manually with:

```bash
$ gem install rexml
```

[source](https://stackoverflow.com/questions/65479863/rails-6-1-what-is-preventing-tests-from-running)

# Run An Older Version Of Bundler

You can check your current version of bundler like so:

```bash
$ bundle --version
1.17.3
```

If you have older versions of bundler, you run against those by specifying the
version in the command:

```bash
$ bundle _1.16.6_ --version
1.16.6
```

Likewise this can be used with any bundler command:

```bash
$ bundle _1.16.6_ install
```

[source](https://makandracards.com/makandra/9741-run-specific-version-of-bundler)

# Running A Single MiniTest Example

Consider the following
[MiniTest](http://ruby-doc.org/stdlib-2.0.0/libdoc/minitest/rdoc/MiniTest.html)
file:

```ruby
# test_stuff.rb
require 'minitest/autorun'

class TestStuff < MiniTest::Unit::TestCase
  def test_first_thing
    assert_equal 4, (2 * 2)
  end

  def test_second_thing
    assert_equal 9, (3 * 3)
  end
end
```

If we want to run all the tests in this file, we can do so with:

```bash
$ ruby test_stuff.rb
```

But what if we want to run a specific test? We can target a single MiniTest
example with the `--name` flag and the name of that example. We can do
something like the following:

```bash
$ ruby test_stuff.rb --name test_second_thing
```

[source](http://stackoverflow.com/a/5292885/535590)

# Safe Navigation Operator

With the release of Ruby 2.3, the *safe navigation operator* (`&.`) is now
available. This addition to the Ruby language allows you to collapse all
those pesky `nil` checks into the accessor call they are guarding. Consider
this snippet of common Ruby code:

```ruby
if user && user.authenticate(params[:password])
  # proceed with logged in user
end
```

With the *safe navigation operator*, the predicate can now be collapsed:

```ruby
if user&.authenticate(params[:password])
  # proceed with logged in user
end
```

If `user` is `nil`, then the predicate will evaluate to `false` and the body
of the if-statement will be passed over.

[Source](http://nithinbekal.com/posts/ruby-2-3-features/)

# Scripting With RVM

Because of how [RVM](https://rvm.io/) works under the hood, you have to do a
couple things to get it to work in a script.

First, you need to ensure that your script is using `bash` instead of `sh`,
so add this to the top of your scripts:

```bash
#!/bin/bash
```

You'll then want to make sure that RVM is sourced. Their
[docs](https://rvm.io/workflow/scripting) recommend sourcing in a script
like this:

```bash
# Load RVM into a shell session *as a function*
if [[ -s "$HOME/.rvm/scripts/rvm" ]] ; then

  # First try to load from a user install
  source "$HOME/.rvm/scripts/rvm"

elif [[ -s "/usr/local/rvm/scripts/rvm" ]] ; then

  # Then try to load from a root install
  source "/usr/local/rvm/scripts/rvm"

else

  printf "ERROR: An RVM installation was not found.\n"

fi
```

After that, you can utilize any of the capabilities of RVM in your script as
you'd like.

# Scroll To Top Of Page With Capybara

During a browser-based Capybara test, you may get partially scrolled down in
the page which can obscure or overlay DOM elements. A sure-fire way to
scroll back to the top is by executing the following line of JavaScript:

```ruby
page.execute_script "window.scrollTo(0,0)"
```

This will scroll to `0,0` which is the top-most, left-most corner of the
browser.

# Set RVM Default Ruby

The default version of Ruby can be set for RVM using the `--default` flag.
For instance, to set the default version of Ruby to `ruby-2.2.3`, use the
following command:

```
$ rvm --default use ruby-2.2.3
```

# Show Public Methods With Pry

Open up a [`pry`](https://github.com/pry/pry) session and use the `-m` flag
with the `ls` command to show just the public methods for an object.

```ruby
> ls -m :hello
Comparable#methods: <  <=  >  >=  between?
Symbol#methods:
  <=>  as_json      empty?    length              slice     to_sym
  ==   capitalize   encoding  match               succ      upcase
  ===  casecmp      id2name   next                swapcase
  =~   downcase     inspect   pretty_print_cycle  to_proc
  []   duplicable?  intern    size                to_s
```

[source](https://github.com/pry/pry/wiki/State-navigation#Ls)

# Silence The Output Of A Ruby Statement In Pry

Sometimes running a command in a [`pry`](https://github.com/pry/pry) session
can produce a bunch of verbose output that you aren't interested in seeing.

Here is a contrived line of code whose output will take over the entire screen:

```ruby
(1..200).map { |i| i*i }
#=> [1,
4,
9,
16,
...
```

You can silence all of this output by tacking on a single character -- `;`.

```ruby
(1..200).map { |i| i*i };
```

[source](https://gist.github.com/lfender6445/9919357)

# Single And Double Quoted String Notation

If you are building a string that involves interpolation and literal double
quotes, then you'll have to do some escaping. Here is an example:

```ruby
> feet, inches = [6, 4]
> puts "I am #{feet}'#{inches}\" tall"
I am 6'4" tall
```

Having to escape a single instance of a double quote isn't so bad. If you find
yourself having to do it a bunch, Ruby has something for you. It is a string
syntax feature called [Percent Notation](percent-notation.md).

You can use percent notation to define double-quoted strings using `Q`:

```ruby
> puts %Q[I am #{feet}'#{inches}" tall]
I am 6'4" tall
```

No need to escape the double quote here.

There is a single-quoted version as well using `q`:

```ruby
> puts %q[I am #{feet}'#{inches}\" tall]
I am #{feet}'#{inches}\" tall
```

This is notably less useful than `%Q`. For that reason, `%Q` makes sense as a
default and it makes up the percent notations unmodified behavior:

```ruby
> puts %[I am #{feet}'#{inches}" tall]
I am 6'4" tall
```

# Skip Specific CVEs When Auditing Your Bundle

The [`bundler-audit` gem](https://github.com/rubysec/bundler-audit) is a tool
that can check for CVEs (Common Vulnerabilities and Exposures) in the installed
versions of gems in your Ruby project. This is a great addition to a CI
pipeline to ensure you aren't deploying code with vulnerabilities.

If you have a known CVE in one of your dependencies, I recommend installing a
patch as soon as possible. Of course, we have to apply some nuance to that
statement.

It is possible that we need to temporarily ignore the CVE warning to continue
to ship code while we work on integrating the patch. Or it may be super
low-risk and we are comfortable putting it off for a while.

Use the `--ignore` flag to prevent `bundler-audit` from flagging a specific
CVE.

```bash
$ bundler-audit check --ignore CVE-2022-23837
```

Or if you need to ignore multiple, list them one after another.

```bash
$ bundler-audit check --ignore CVE-2022-23837 CVE-2021-41817
```

If you do skip a CVE in your bundle audit, make sure you understand the risks
and have a plan for dealing with it in the future.

See `bundler-audit --help` or [their
docs](https://github.com/rubysec/bundler-audit) for more details.

# Squeeze Out The Extra Space

Remove all the excess spaces from a string using the squeeze method:

```ruby
> "this  is   a string".squeeze(' ')
=> "this is a string"
```

# String Interpolation With Instance Variables

When using regular variables with string interpolation in Ruby, they must be
wrapped in curly braces (e.g. `"This is a #{variable}"`). With instance
variables (and class and global variables) you can just use the _octothorp_
followed directly by the variable.

Here is an example of this in action:

```ruby
class Person
  def initialize(name)
    @name = name
  end

  def whoami
    puts "I am #@name"
  end
end

bob = Person.new("bob")
#=> #<Person:0x007fdaf3291618 @name="bob">

bob.whoami
# I am bob
```

This is a handy shortcut, but may affect readability and/or result in an
interpolation error at some point. Your mileage may vary.

h/t Josh Davey

# Summing Collections

Given a hash, `my_hash`,

```ruby
my_hash = {
    "one" => 1,
    "two" => 2,
    "three" => 5
}
```

I want to determine the sum of the values in `my_hash`, which should be `8`.

This is similar to asking for the sum of the values in an array. In fact,
using `#values` on `my_hash` will leave us with the task of summing the
values in an array.

It turns out that to sum the values in an array, all you need is `#inject`

```ruby
[1,2,5].inject(:+)
=> 8
```

So, if I want the sum of the values in a hash, such as `my_hash`, then all
that is needed is

```ruby
my_hash.values.inject(:+)
=> 8
```

To take this one step further, let's consider what will happen with an empty
array. The above approach will produce `nil`. If we want `0` when the list
is empty, then tell `#inject` to do just that

```ruby
[].inject(0, :+)
=> 0
```

[source](http://stackoverflow.com/questions/1538789/how-to-sum-array-of-numbers-in-ruby)

# Triple Equals: The Case Equality Operator

The standard equality operator in Ruby is the double equals (`==`).

```ruby
> 2 + 2 == 4
=> true
```

Ruby supports another operator that looks sneakily like this, but with
different behavior. It's the triple equals (`===`) which is called the [case
equality
operator](https://ruby-doc.org/core-3.0.3/Object.html#method-i-3D-3D-3D) (or
case subsumption operator).

Though the specific behavior can be overridden on a class by class basis, the
operator is generally used to check if the first operand is a bucket that the
second operand fits into.

Here are some examples:

```ruby
> (1..10) === 5
=> true
> (1..10) === 13
=> false

> Integer === 7
=> true
> Integer === 'nope'
=> false

> /fun/ === "fundamentals"
=> true
> /taco/ === "fundamentals"
=> false

> Object === String
=> true
> String === Object
=> false
```

It's important to understand how this works because `===` is the operator used
under the hood by Ruby's case statements.

[source](https://stackoverflow.com/questions/4467538/what-does-the-operator-do-in-ruby/4467823#4467823)

# Turn Key And Value Arrays Into A Hash

Let's say you have an array of keys and an array of values:

```ruby
keys = [:title, :author, :year]
values = ["The Fifth Season", "N. K. Jemisin", 2015]
```

You can turn them into a hash where the keys of that hash come from `keys` and
are tied in order, one-to-one with the `values`.

A `hash` can be created from an array of tuples, where each is a key-value
pairing. Knowing this, we can `zip` the two arrays together and then turn them
into a `hash` like so:

```ruby
> Hash[keys.zip(values)]
#=> {:title=>"The Fifth Season", :author=>"N. K. Jemisin", :year=>2015}
```

[source](https://stackoverflow.com/a/23113943/535590)

# Turning Any Class Into An Enumerator

At the core of any enumerator is the ability to respond to an `#each` call.
With that in mind, we prepare any class for being turned into an enumerator.

Consider this class `SquaresCollection` that allows you to turn an array of
integers into an array of its squares.

```ruby
class SquaresCollection
  def initialize(items)
    @items = items
  end

  def run
    @items.map { |item| item * item }
  end
end

SquaresCollection.new([1,2,3]).run #=> [1,4,9]
```

We can work with this, but it opts out of Ruby's enumerator offerings.

We can, instead, provide an `#each` method which allows instances of our
`SquaresCollection` class to be turned into enumerators.

```ruby
class SquaresCollection
  def initialize(items)
    @items = items
  end

  def each
    return enum_for(:each) unless block_given?

    @items.each do |item|
      yield item * item
    end
  end
end
```

Here is how we can use it:

```ruby
sc = SquaresCollection.new([1,2,3])

puts sc.to_enum
#=> <Enumerator ...>

puts sc.to_enum.map { |item| "* #{item} *" }
#=> ["* 1 *", "* 4 *", "* 9 *"]
```

The [`#to_enum`](https://devdocs.io/ruby~2.5/object#method-i-to_enum) method
looks for an `#each` method on the instance's class and uses that to create an
enumerator.

[source](https://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/)

# Turning Things Into Hashes

We have `#to_h` for turning things into hashes.

It works as an identity function:

```ruby
> {}.to_h
=> {}
> {hello: "world"}.to_h
=> {:hello=>"world"}
```

It works with `nil`:

```ruby
> nil.to_h
=> {}
```

Does it work with arrays?

```ruby
> [:one, 2].to_h
TypeError: wrong element type Symbol at 0 (expected array)
from (pry):36:in `to_h'
```

Yes, but only if it is an array of pairs:

```ruby
> [[:one, 2], [:three, 4]].to_h
=> {:one=>2, :three=>4}
```

It also works with `Struct` and `OpenStruct`:

```
> Person = Struct.new(:name, :age)
=> Person
> bob = Person.new("bob", 45)
=> #<struct Person name="bob", age=45>
> bob.to_h
=> {:name=>"bob", :age=>45}
```

You'll find that many other objects and gems support `#to_h` when it makes
sense.

# Uncaught Exceptions In Pry

You are fiddling around with some code in a pry session trying to
familiarize yourself with how it all works. You suddenly execute a statement
that results in an uncaught exception. You'd like to take a closer look at
the exception. Pry makes this easy by exposing the `_ex_` variable which
points to the last uncaught exception.

Try it out in a pry session:

```ruby
> class MyError < StandardError; end
=> nil
> def do_stuff; raise MyError, "Something bad happened"; end
=> :do_stuff
> do_stuff
MyError: Something bad happened
from (pry):2:in `do_stuff'
> _ex_
=> #<MyError: Something bad happened>
```

# `undef_method` And The Inheritance Hierarchy

As the docs state, Ruby's
[`undef_method`](http://ruby-doc.org/core-2.2.0/Module.html#method-i-undef_method)

> prevents the current class from responding to calls to the named method.

This means you can do some weird things to the inheritance hierarchy. I'll
use the following code example to illustrate.

```ruby
class Phone
  def ring
    puts 'brrrrriiing'
  end
end

class Smartphone < Phone
  def ring
    puts 'boop beep boop'
  end
end

class Iphone < Smartphone
end

smartphone = Smartphone.new
iphone = Iphone.new

smartphone.ring
#=> boop beep boop
iphone.ring
#=> boop beep boop
```

Everything works as expect. Now, I'll use `undef_method`.

```ruby
class Smartphone
  undef_method(:ring)
end

smartphone.ring
#=> NoMethodError: undefined method `ring' for #<Smartphone:0x007fd0a20b7960>
iphone.ring
#=> NoMethodError: undefined method `ring' for #<Iphone:0x007fd0a20b7938>
```

Not only have instances of `Smartphone` been prevented from responding to
`ring`, but any subclasses of `Smartphone` that call `ring` will get tripped
up when traversing the inheritance hierarchy in search of a definition of
`ring`.

# Uninstall Specific Version Of A Ruby Gem

I have two versions of `bundler` installed on my machine—`2.2.4` and `2.2.10`.
When I check the version of bundler, I see it references the latest one.

```bash
$ bundle --version
Bundler version 2.2.10
```

I want to get rid of `2.2.10` so that I can use `2.2.4` instead. This can be
done by uninstalling that specific version of `bundler`.
 
To do this, specify the `-v` flag when running `gem uninstall`.

```bash
$ gem uninstall bundler -v 2.2.10
Successfully uninstalled bundler-2.2.10
$ bundle --version
Bundler version 2.2.4
```

Alternatively, if you want to use a different version of a gem without
uninstalling the primary version, you can [specify the version after the gem
name when calling it](run-an-older-version-of-bundler.md).

[source](https://stackoverflow.com/questions/23887726/rails-uninstall-specific-version-of-a-library-using-gem)

# Unpacking Strings Into Binary

You can find the binary representation of a given string by decoding it. Ruby
comes equipped with the [`#unpack`](https://apidock.com/ruby/String/unpack)
method on the `String` class that can do this decoding.

Though there are a variety of formats to decode a string into, here are some
example of decoding different characters into binary.

```ruby
> "A".unpack("B*")
=> ["01000001"]
```

The `B*` says _unpack_ this into as many *B*inary digits as are needed. The
UTF-8 encoding, means only a single byte (8-bits) are needed to represent
`"A"`.

```ruby
irb(main):002:0> "Æ".unpack("B*")
=> ["1100001110000110"]
irb(main):003:0> "Æ".unpack("B8 B8")
=> ["11000011", "10000110"]
```

`"Æ"` is represented by two bytes. We can unpack each byte seprarately using
`"B8 B8"`.

```ruby
irb(main):004:0> "木".unpack("B*")
=> ["111001101001110010101000"]
irb(main):005:0> "木".unpack("B8 B8 B8")
=> ["11100110", "10011100", "10101000"]
```

Similarly, this Japanese character is represented by three bytes of data.

```ruby
irb(main):006:0> "👻".unpack("B*")
=> ["11110000100111111001000110111011"]
irb(main):007:0> "👻".unpack("B8 B8 B8 B8")
=> ["11110000", "10011111", "10010001", "10111011"]
```

Lastly, emojis generally require four bytes of data.

[source](https://www.honeybadger.io/blog/the-rubyist-guide-to-unicode-utf8/)

# Up And Down With Integers

Ruby's [`Integer`](http://ruby-doc.org/core-2.2.0/Integer.html) class comes
with an `#upto` and a `#downto` method. Both of these methods can be used to
iterate from one number up or down to, respectively, another number.

Let's count to 3

```ruby
> 1.upto(3) { |x| puts x }
1
2
3
```

This of course can easily and perhaps more idiomatically be accomplished
with a range and the `#each` method (e.g. `(1..3).each { |x| puts x }`.

We cannot, however, simulate the `#downto` method with a range (at least,
not very cleanly). So, if you need to count down to something, this is going
to be the cleanest and clearest way.

```ruby
> 5.downto(2) { |x| puts x }
5
4
3
2
```

The return value for both methods is always the integer we started with.

# Update The Gemfile Bundled With Version

When you run `bundle install`, whatever is the latest version of `bundler`
installed locally will be used. Your `Gemfile` dependencies will be installed
and the `Gemfile.lock` will be marked at the bottom with a signature for the
version of `bundler` that was used.

```ruby
# Gemfile.lock
...

BUNDLED WITH
   1.1.17
```

On future `bundle install` calls, a matching major version of Bundler will be
used. If you'd like to migrate from 1.x.x to 2.x.x or vice versa, or even if
you want to explicitly change minor versions, you can run:

```bash
$ bundle update --bundler=2.2.4
```

This will bundle your project with `2.2.4` and update the `BUNDLED WITH`
section to reflect that.

Use the version that makes sense for you with the `--bundler` flag.

[source](https://bundler.io/guides/bundler_2_upgrade.html#upgrading-applications-from-bundler-1-to-bundler-2)

# Use A Case Statement As A Cond Statement

Many languages come with a feature that usually takes the name _cond
statement_. It is essentially another way of writing an _if-elsif-else_
statement. The first conditional in the _cond statement_ to evaluate to true
will then have its block evaluated.

Ruby doesn't have a _cond statement_, but it does have a _case statement_.
By using a _case statement_ with no arguments, we get a _cond statement_. If
we exclude arguments and then put arbitrary conditional statements after the
`when` keywords, we get a construct that acts like a _cond statement_. Check
out the following example:

```ruby
some_string = "What"

case
when some_string.downcase == some_string
  puts "The string is all lowercase."
when some_string.upcase == some_string
  puts "The string is all uppercase."
else
  puts "The string is mixed case."
end

#=> The string is mixed case.
```

[source](http://www.skorks.com/2009/08/how-a-ruby-case-statement-works-and-what-you-can-do-with-it/)

# Use dotenv In A Non-Rails Project

Up to now I've only used [`dotenv`](https://github.com/bkeepers/dotenv) in a
Rails context. It can just as easily be used in a plain old Ruby project.

Install the non-Rails version of the gem.

```bash
$ gem install dotenv
```

Then add the following lines wherever you want `dotenv` included and loaded.
In my case, I want it pulled in as part of my RSpec setup in
`spec_helper.rb`.

```ruby
require 'dotenv'
Dotenv.load
```

Your environment variables declared in `.env` are now accessible via fetches
against the `ENV` object.

```ruby
ENV.fetch('my_env_var')
```

# Use Tap For Better Test Data Setup

I often use RSpec's `let` statement to set up some test data.

```ruby
let(:order) { create(:order, name: "My Order") }
```

Often times, realistic test data requires setting up peripheral data as well.

```ruby
let(:order) do
  order = create(:order, name: "My Order")
  create(:item, name: "Burger", order: order, price: 4.99)
  create(:item, name: "Fries", order: order, price: 2.99)
  order
end
```

This can get hard to read as the subject of the `let` gets obscured. It is also
clumsy that we have to end with returning the `order`. This can be cleaned up
with the use of [`#tap`](https://devdocs.io/ruby~2.5/object#method-i-tap).

```ruby
let(:order) do
  create(:order, name: "My Order").tap do |order|
    create(:item, name: "Burger", order: order, price: 4.99)
    create(:item, name: "Fries", order: order, price: 2.99)
  end
end
```

The block notation and indentation make it clear that the `order` is what is
getting created. Meanwhile, the interior of the block gives us a designated
area to do what we need to with the newly-created `order` instance.

# Using BCrypt To Create And Check Hashed Passwords

The [BCrypt](https://github.com/codahale/bcrypt-ruby) library is used under
the hood by gems like Devise in order to work with passwords securely. You
can use it to salt and hash a plain text password. You can also use it to
check whether an encrypted password matches some input password.

```ruby
> include BCrypt
=> Object

> encrypted_pass = Password.create('password')
=> "$2a$10$te3Y8wdSXf8/gWDeSP5z9eut7alThnuTvq1SvgQyJ1C57F.qit1uq"

> Password.new(encrypted_pass) == "not_my_pass"
=> false

> Password.new(encrypted_pass) == "password"
=> true
```

The `Password.create` method will salt and hash the given password. The
resulting encrypted password, if it is an instance of `Password`, can be
directly compared to a string. For good measure, in case the encrypted
password is a string, you can wrap it in a call to `Password.new` to ensure
you are working with a `Password` instance.

# What To Do When You Don't Rescue

Ruby's `rescue` syntax supports a couple different blocks. I was already
familiar with `ensure` which is a block of code that will be executed
regardless of whether or not an exception was rescued.

```ruby
begin
  do_something_that_could_fail()
rescue StandardError => e
  # oh no!
ensure
  Logging.info("We attempted to do the thing.")
end
```

What if you want to differentiatee between an instance when your code ran
without incident and when there was an exception? Ruby's `rescue` syntax also
supports an `else` block. The `else` block is executed only when nothing is
rescued.

```ruby
begin
  do_something_that_could_fail()
rescue StandardError => e
  Logging.info("We tried to do something and it failed.")
else
  Logging.info("We successfully did the thing!")
end
```

There are a lot of ways to use this. Here I was able to differentiate the
messaging in my logging based on whether or not an exception occurred.

[source](https://blog.bigbinary.com/2017/10/24/ruby-2.5-allows-rescue-inside-do-end-blocks.html)

# Who Are My Ancestors?

Ruby's `Module` class provides the
[`#ancestors`](http://ruby-doc.org/core-2.1.0/Module.html#method-i-ancestors)
method. This method allows you to determine the ancestors (parents,
grandparents, etc.) of a given class.

```ruby
> 5.class.ancestors
=> [Fixnum, Integer, Numeric, Comparable, Object, PP::ObjectMixin, Kernel, BasicObject]
> Array.ancestors
=> [Array, Enumerable, Object, PP::ObjectMixin, Kernel, BasicObject]
> Class.ancestors
=> [Class, Module, Object, PP::ObjectMixin, Kernel, BasicObject]
> BasicObject.ancestors
=> [BasicObject]
```

# Wrap Things In An Array, Even Hashes

I've always used `Kernel::Array` to wrap things in an array. It works great.

```ruby
> Array(nil)
#=> []
> Array(1)
#=> [1]
> Array(["hello", "world"])
#=> ["hello", "world"]
```

Except with hashes, it might not do what you expect when given a hash.

```ruby
> Array({a: 1, b: 2})
#=> [[:a, 1], [:b, 2]]
```

I just wanted the hash wrapped in an array, not turned into an array of tuples.

The `Array` class has a method `#wrap` which behaves similarly to
`Kernal::Array` while also handling hashes in the way I was wanting.

```ruby
> Array.wrap(nil)
#=> []
> Array.wrap(1)
#=> [1]
> Array.wrap(["hello", "world"])
#=> ["hello", "world"]
> Array.wrap({a: 1, b: 2})
#=> [{a: 1, b: 2}]
```

[source](https://devdocs.io/rails~5.2/array#method-c-wrap)

# Zero Padding

Ruby makes zero-padding strings to a fixed length easy with `String#rjust`.

```ruby
> "1234".rjust(6, "0")
=> "001234"
> "123456".rjust(6, "0")
=> "123456"
```

In the same way, you can pad zeros on the other side of the string with
`String#ljust`.

```ruby
> "12".ljust(4, "0")
=> "1200"
> "".ljust(4, "0")
=> "0000"
```

h/t Dillon Hafer

