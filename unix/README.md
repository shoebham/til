### Category unix

---

 - [All The Environment Variables](#all-the-environment-variables)
 - [Cat A File With Line Numbers](#cat-a-file-with-line-numbers)
 - [Cat Files With Color Using Bat](#cat-files-with-color-using-bat)
 - [Change Default Shell For A User](#change-default-shell-for-a-user)
 - [Change To That New Directory](#change-to-that-new-directory)
 - [Check If A Port Is In Use](#check-if-a-port-is-in-use)
 - [Check If Command Is Executable Before Using](#check-if-command-is-executable-before-using)
 - [Check The Current Working Directory](#check-the-current-working-directory)
 - [Clear The Screen](#clear-the-screen)
 - [Command Line Length Limitations](#command-line-length-limitations)
 - [Compare Two Variables In A Bash Script](#compare-two-variables-in-a-bash-script)
 - [Configure cd To Behave Like pushd In Zsh](#configure-cd-to-behave-like-pushd-in-zsh)
 - [Copying File Contents To System Paste Buffer](#copying-file-contents-to-system-paste-buffer)
 - [Copying Nested Directories With Ditto](#copying-nested-directories-with-ditto)
 - [Count The Number Of Matches In A Grep](#count-the-number-of-matches-in-a-grep)
 - [Create A File Descriptor with Process Substitution](#create-a-file-descriptor-with-process-substitution)
 - [Create A Sequence Of Values With A Step](#create-a-sequence-of-values-with-a-step)
 - [Curl With Cookies](#curl-with-cookies)
 - [Curling For Headers](#curling-for-headers)
 - [Curling With Basic Auth Credentials](#curling-with-basic-auth-credentials)
 - [Display All The Terminal Colors](#display-all-the-terminal-colors)
 - [Display Free Disk Space](#display-free-disk-space)
 - [Display The Contents Of A Directory As A Tree](#display-the-contents-of-a-directory-as-a-tree)
 - [Do A Dry Run Of An rsync](#do-a-dry-run-of-an-rsync)
 - [Do Not Overwrite Existing Files](#do-not-overwrite-existing-files)
 - [Enable Multi-Select Of Results With fzf](#enable-multi-select-of-results-with-fzf)
 - [Exclude A Directory With Find](#exclude-a-directory-with-find)
 - [Exclude Certain Files From An rsync Run](#exclude-certain-files-from-an-rsync-run)
 - [Figure Out The Week Of The Year From The Terminal](#figure-out-the-week-of-the-year-from-the-terminal)
 - [File Type Info With File](#file-type-info-with-file)
 - [Find A File Installed By Brew](#find-a-file-installed-by-brew)
 - [Find Files With fd](#find-files-with-fd)
 - [Find Newer Files](#find-newer-files)
 - [Fix Unlinked Node Binaries With asdf](#fix-unlinked-node-binaries-with-asdf)
 - [Forward Multiple Ports Over SSH](#forward-multiple-ports-over-ssh)
 - [Generate A SAML Key And Certificate Pair](#generate-a-saml-key-and-certificate-pair)
 - [Get Matching Filenames As Output From Grep](#get-matching-filenames-as-output-from-grep)
 - [Get The Unix Timestamp](#get-the-unix-timestamp)
 - [Global Substitution On The Previous Command](#global-substitution-on-the-previous-command)
 - [Globbing For All Directories In Zsh](#globbing-for-all-directories-in-zsh)
 - [Globbing For Filenames In Zsh](#globbing-for-filenames-in-zsh)
 - [Grep For Files Without A Match](#grep-for-files-without-a-match)
 - [Grep For Files With Multiple Matches](#grep-for-files-with-multiple-matches)
 - [Grep For Multiple Patterns](#grep-for-multiple-patterns)
 - [Hexdump A Compiled File](#hexdump-a-compiled-file)
 - [Ignore The Alias When Running A Command](#ignore-the-alias-when-running-a-command)
 - [Interactively Browse Available Node Versions](#interactively-browse-available-node-versions)
 - [Jump To The Ends Of Your Shell History](#jump-to-the-ends-of-your-shell-history)
 - [Kill Everything Running On A Certain Port](#kill-everything-running-on-a-certain-port)
 - [Killing A Frozen SSH Session](#killing-a-frozen-ssh-session)
 - [Last Argument Of The Last Command](#last-argument-of-the-last-command)
 - [Less With Style](#less-with-style)
 - [List All Users](#list-all-users)
 - [List Files Ordered By Modification Date](#list-files-ordered-by-modification-date)
 - [List Names Of Files With Matches](#list-names-of-files-with-matches)
 - [List Of Sessions To A Machine](#list-of-sessions-to-a-machine)
 - [List Parent pid With ps](#list-parent-pid-with-ps)
 - [List Stats For A File](#list-stats-for-a-file)
 - [List The Available JDKs](#list-the-available-jdks)
 - [List The Stack Of Remembered Directories](#list-the-stack-of-remembered-directories)
 - [Map A Domain To localhost](#map-a-domain-to-localhost)
 - [Only Show The Matches](#only-show-the-matches)
 - [Open The Current Command In An Editor](#open-the-current-command-in-an-editor)
 - [Partial String Matching In Bash Scripts](#partial-string-matching-in-bash-scripts)
 - [PID Of The Current Shell](#pid-of-the-current-shell)
 - [Print A Range Of Lines For A File With Bat](#print-a-range-of-lines-for-a-file-with-bat)
 - [Print Out Files In Reverse](#print-out-files-in-reverse)
 - [Provide A Fallback Value For Unset Parameter](#provide-a-fallback-value-for-unset-parameter)
 - [Repeat Yourself](#repeat-yourself)
 - [Saying Yes](#saying-yes)
 - [Search Files Specific To A Language](#search-files-specific-to-a-language)
 - [Search History](#search-history)
 - [Search Man Page Descriptions](#search-man-page-descriptions)
 - [Securely Remove Files](#securely-remove-files)
 - [Set The asdf Package Version For A Single Shell](#set-the-asdf-package-version-for-a-single-shell)
 - [Show A File Preview When Searching With FZF](#show-a-file-preview-when-searching-with-fzf)
 - [Show Disk Usage For The Current Directory](#show-disk-usage-for-the-current-directory)
 - [Show The Size Of Everything In A Directory](#show-the-size-of-everything-in-a-directory)
 - [Skip Paging If Output Fits On Screen With Less](#skip-paging-if-output-fits-on-screen-with-less)
 - [SSH Escape Sequences](#ssh-escape-sequences)
 - [SSH With Port Forwarding](#ssh-with-port-forwarding)
 - [Specify The Language For A File With Bat](#specify-the-language-for-a-file-with-bat)
 - [Sort In Numerical Order](#sort-in-numerical-order)
 - [Switch Versions of a Brew Formula](#switch-versions-of-a-brew-formula)
 - [Touch Access And Modify Times Individually](#touch-access-and-modify-times-individually)
 - [Undo Some Command Line Editing](#undo-some-command-line-editing)
 - [Update Package Versions Known By asdf Plugin](#update-package-versions-known-by-asdf-plugin)
 - [Use fzf To Change Directories](#use-fzf-to-change-directories)
 - [Use Regex Pattern Matching With Grep](#use-regex-pattern-matching-with-grep)
 - [View A Web Page In The Terminal](#view-a-web-page-in-the-terminal)
 - [Watch The Difference](#watch-the-difference)
 - [Watch This Run Repeatedly](#watch-this-run-repeatedly)
 - [Where Are The Binaries?](#where-are-the-binaries?)

---

# All The Environment Variables

If you want to see all the environment variables defined on your machine,
you can list them all out with `printenv`. If you are like me, you probably
have a ton of them. Pipe it through `less` to make it easier to navigate and
search through (i.e. `printenv | less`).

# Cat A File With Line Numbers

You can quickly view a file using `cat`

```
$ cat Gemfile
source 'https://rubygems.org'


# Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
gem 'rails', '4.2.0'
# Use postgresql as the database for Active Record
gem 'pg'
```

With the `-n` flag you can view that file with line numbers

```
$ cat -n Gemfile
 1  source 'https://rubygems.org'
 2  
 3  
 4  # Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
 5  gem 'rails', '4.2.0'
 6  # Use postgresql as the database for Active Record
 7  gem 'pg'
```

# Cat Files With Color Using Bat

The time-tested utility `cat` is probably one of the most used unix
commands. It prints the contents of the file to stdout. You can use it to
get a quick view of a file.

![example of cat](https://i.imgur.com/kb1UjPW.png)

We live in a world of color and our terminal emulators are capable of so
much more. There is an alternative to `cat`, called `bat`, that provides
syntax highlighting based on the type of file.

![example of bat](https://i.imgur.com/ieL7v2Q.png)

This is an open-source utility written in Rust. You can check it out on
[github](https://github.com/sharkdp/bat).

# Change Default Shell For A User

You can change the default shell program for a particular unix user with the
`chsh` command. Just tell it what shell program you want to use (e.g. `bash`
or `zsh`) and which user the change is for:

```
$ [sudo] chsh -s /usr/bin/zsh username
```

This command needs to be invoked with root privileges.

This command updates the entry for that user in the `/etc/passwd` file.

[source](http://superuser.com/questions/46748/how-do-i-make-bash-my-default-shell-on-ubuntu)

# Change To That New Directory

The `$_` variable provided by bash is always set to the last argument of the
previous command. One handy use of this is for changing directories into a
newly created directory.

```bash
$ mkdir new_dir && cd $_
```

This command will leave you in your newly created directory, `new_dir`.

We can imagine using this bash variable in a number of similar scenarios as
well. What if we are using some language specific command that creates a
directory? Will it work when creating a new Phoenix or Rails project?

It sure will.

Give it a try with Phoenix:

```bash
mix phx.new my_app && cd $_
```

or with Rails:

```bash
rails new app && cd $_
```

[source](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html)

# Check If A Port Is In Use

The `lsof` command is used to *list open files*. This includes listing
network connections. This means I can check if a particular port is in use
and what process is using that port. For instance, I can check if my rails
application is currently running on port 3000.

```
$ lsof -i TCP:3000
COMMAND   PID       USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
ruby    13821 jbranchaud   12u  IPv6 0xdf2e9fd346cc12b5      0t0  TCP localhost:hbci (LISTEN)
ruby    13821 jbranchaud   13u  IPv4 0xdf2e9fd33ca74d65      0t0  TCP localhost:hbci (LISTEN)
```

I can see that a ruby process (my rails app) is using port 3000. The PID
and a number of other details are included.

See more details with `man lsof`.

h/t [Mike Chau](https://twitter.com/money_mikec)

# Check If Command Is Executable Before Using

When writing a quick bash script, you may want to check if a command exists and
is executable before trying to call it. This can be done with `command`, a builtin shell command, and the `-v` flag.

> If the -V or -v option is supplied, the exit status is 0 if command was found, and 1 if not.

Knowing that, we can redirect the output of the command to `/dev/null` and then
short-circuit executing the command if it's not available.

```bash
command -v pbcopy >/dev/null 2>&1 && echo 'something' | pbcopy
```

In this example, I execute the `pbcopy` command, which copies text to my system
clipboard, only if that command is available and executable.

See `man bash` and find the listing for `command` for more details.

# Check The Current Working Directory

Use

```
$ pwd
```

to display the absolute path of the current working directory.

See `man pwd` for more details.

# Clear The Screen

If you type `clear` into your shell, the screen will be cleared. There is a
handy keybinding though that will save you a few keystrokes. Just hit
`ctrl-l` to achieve the same effect.

source: [Derek P.](https://twitter.com/DerkTheDaring)

# Command Line Length Limitations

The other day I tried to run a `rm` command on the contents of a directory
with a **LOT** of files.

```
$ rm images/*
```

Instead of deleting the contents of the directory, the following message was
displayed:

```
/bin/rm: cannot execute [Argument list too long]
```

Bash wanted to expand the entire command before executing it. It was too
long. But what is too long?

It turns out that we can figure out the max length of commands with the
following command:

```
$ getconf ARG_MAX
```

For me, the result is `262144`.

[source
1](http://stackoverflow.com/questions/11289551/argument-list-too-long-error-for-rm-cp-mv-commands)
and [source
2](http://www.cyberciti.biz/faq/argument-list-too-long-error-solution/)

# Compare Two Variables In A Bash Script

You can compare two variables in a bash script with an `if` block like so:

```bash
if [ "$EDITOR" = "$PREFERRED_EDITOR" ]; then
  # do something ...
fi
```

If those variables are equal, then the contents of the `if` block will be
executed.

Notice that both variables are wrapped in quotes. This is to avoid a potential
syntax error. If the quotes were excluded and one of the variables happened to
be unset, then the comparison would evaluate to:

```bash
if [ "vim" = ]; then
  # do something ...
fi
```

That would cause an error, rather than evaluating to false and moving in.
Wrapping each in quotes allows an unset variable to turn into an empty string
(`""`).

# Configure cd To Behave Like pushd In Zsh

The Zsh environment has a setting that allows you to make the `cd` command
behave like the `pushd` command. Normally when you use `cd` the [remembered
directory stack](list-the-stack-of-remembered-directories.md) is not
effected. However, if you add the following setting to your `~/.zshrc` file:

```bash
setopt auto_pushd
```

then using `cd` to navigate directories will cause those directories to be
added to the `dirs` stack.

This is the default in the [oh-my-zsh configuration of
zsh](https://github.com/robbyrussell/oh-my-zsh/blob/master/lib/directories.zsh#L2).

# Copying File Contents To System Paste Buffer

If you need to copy and paste the contents of a file, the `pbcopy` command
can be one of the best ways to accomplish this. Simply `cat` the file and
pipe that into `pbcopy` to get the contents of the file into the system
paste buffer.

```
$ cat some-file.txt | pbcopy
```

See `man pbcopy` for more details.

# Copying Nested Directories With Ditto

You can copy nested directories with `cp` using the `-R` (_recursive_) flag.
The way `cp` works is that it replaces the target location with the source
directory, wiping out whatever files or directories reside at the target
location.

Conversely, the `ditto` utility, available on OS X's version of Unix, does
_recursive_ directory copies by default and merges the contents of any existing
directories.

As an example, here are two folders, `folder1` and `folder2`:

```bash
❯ exa -T folder1
folder1
├── cats
│  └── sneaky
└── dogs
   └── fido

❯ exa -T folder2
folder2
└── cats
   └── oreo
```

Using `ditto` to copy `folder1` to `folder2`

```bash
❯ ditto folder1 folder2
```

we get a `folder2` where directories from `folder1` are created and existing
directories are merged together.

```bash
❯ exa -T folder2
folder2
├── cats
│  ├── oreo
│  └── sneaky
└── dogs
   └── fido
```

See `man ditto` for more details.

# Count The Number Of Matches In A Grep

My go to way of counting the number of matches in a `grep` of a file is to pipe
it to another command — `wc`.

Here is what that looks like with the README for [this
repo](https://github.com/jbranchaud/til). This counts the number of lines that
start with `###`.

```bash
$ grep '^###' README.md | wc -l
      48
```

When `wc` is used with the `-l` flag, it gives a count of the number of lines.
In this case the number of `grep` matches that get piped to it.

There is another way to do this solely with the `grep` command — using the `-c`
flag.

```bash
$ grep -c '^###' README.md
48
```

When you include the `-c` (or `--count`) flag with `grep`, instead of the
matches being output, the count of the matches is output.

See `man grep` for more details.

# Create A File Descriptor with Process Substitution

Process substitution can be used to create a file descriptor from the
evaluation of a shell command. The syntax for process substitution is
`<(LIST)` where `LIST` is one or more bash commands.

```
$ cat <(echo 'hello, world')
hello, world
```

This is particularly useful for commands that expect files, such as diff:

```
$ diff <(echo 'hello, world') <(echo 'hello, mars')
1c1
< hello, world
---
> hello, mars
```

Sources: [Brian Dunn](https://twitter.com/higgaion) and
[Bash Guide for Beginners](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_04.html#sect_03_04_07)

# Create A Sequence Of Values With A Step

The `seq` utility allows you to output a sequence of values.

You can start at `1` by default.

```bash
$ seq 3
1
2
3
```

Or you can specify the starting value.

```bash
$ seq 10 13
10
11
12
13
```

Adding a third argument in between those two will specify the step value that
should be taken to get from one to the other.

```bash
$ seq 6 3 15
6
9
12
15
```

That sequence starts at 6 and goes to 15 with a step value of 3.

See `man seq` for more details.

# Curl With Cookies

Some endpoints require certain cookies to be included in order to get the
response you are looking for. For instance, if the endpoint is authenticated
with a session cookie, then you will need to provide that session cookie when
curling.

The `-b` flag can be used to instruct `curl` to include a cookie in the header
of a request.

```bash
$ curl -b session=abc123SessionToken https://authenticated-url.com
```

See `man curl` for more details and other flags.

# Curling For Headers

If you want to inspect the headers of a response from some endpoint, look no
further than a quick `curl` command. By including the `-I` flag, `curl` will
return just the headers.

For example, if you are developing a web app that is being locally served at
`localhost:3000` and you'd like to see what the headers look like for a
particular URL, you might try something like the following command:

```bash
$ curl -I localhost:3000/posts
```

h/t Dillon Hafer

# Curling With Basic Auth Credentials

I often use `curl` to take a quick look at the responses of particular
endpoints. If I try to `curl` a URL that is secured with HTTP Basic
Authentication, this is what the response looks like:

```bash
$ curl staging.example.com
HTTP Basic: Access denied.
```

I can give the credentials to `curl` so that it can plug them in as it makes
the request using the `-u` (or `--user`) flag:

```bash
$ curl -u username:password staging.example.com
<html><body>...</body></html>
```

If I don't want the password showing up in my command-line history, I can
just provide the username and `curl` will prompt me for my password:

```bash
$ curl -u username staging.example.com
Enter host password for user 'username':
<html><body>...</body></html>
```

See `man curl` for more details.

# Display All The Terminal Colors

The following snippet of bash scripting will print out a nicely formatted
collection of all the terminal colors.

```bash
for x in {0..8}; do 
    for i in {30..37}; do 
        for a in {40..47}; do 
            echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "
        done
        echo
    done
done
echo ""
```

This is a great way to figure out the escape codes you need for coloring and
styling text in a bash script.

[source](https://askubuntu.com/questions/27314/script-to-display-all-terminal-colors)

h/t Dillon Hafer

# Display Free Disk Space

The `df` utility is a handy way to display the free disk space available on
on a specific file system or all mounted file systems.

Use `df` with the `-h` flag to display the disk space usage and availability
in a human-readable format.

Here is the output from a linode box of mine:

```bash
df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/xvda        20G  3.8G   16G  20% /
none            4.0K     0  4.0K   0% /sys/fs/cgroup
devtmpfs        994M  4.0K  994M   1% /dev
none            200M  196K  199M   1% /run
none            5.0M     0  5.0M   0% /run/lock
none            996M     0  996M   0% /run/shm
none            100M     0  100M   0% /run/user
```

h/t Josh Davey

# Display The Contents Of A Directory As A Tree

The [`exa` utility](https://github.com/ogham/exa) is a speedy replacement for
`ls` that offers some additional features. One of those extra features is the
_tree_ display.

By including the `-T` (or `--tree`) flag, `exa` will recurse into a directory
and display the entirety of the contents as a tree.

```bash
❯ exa -T
.
├── folder1
│  ├── cats
│  │  └── sneaky
│  └── dogs
│     └── fido
└── folder2
   ├── cats
   │  ├── oreo
   │  └── sneaky
   └── dogs
      └── fido
```

You can target a specific directory:

```bash
❯ exa -T folder2
folder2
├── cats
│  ├── oreo
│  └── sneaky
└── dogs
   └── fido
```

See `man exa` for more details.

# Do A Dry Run Of An rsync

The `rsync` command, especially when running recursively (with the `-a` flag),
will create and update a bunch of directories and files. Because of that, you
may want to do a _dry run_ of an `rsync` command to make sure it is touching
the intended files.

The `--dry-run` flag (or the `-n` flag for short) will prepare a
synchronization of one directory to another. You can use this flag to be sure
that the source and target files and directories are correct.

The `-n` (or `--dry-run`) flag on its own won't _show_ what is going to get
synced. To get that information, you need to combine it with the `-v` (verbose)
flag.

```bash
$ rsync -anv til-temp/ til-content

building file list ... done
./
LICENSE
...

sent 909 bytes  received 296 bytes  2410.00 bytes/sec
total size is 1058  speedup is 0.88
```

That will show everything that is going to be synced from `til-temp/`
recursively to `til-content`.

Doing a dry run is a great way to make sure you have the patterns for
`--exclude` flags correct, before actually syncing anything.

```bash
$ rsync -anv --exclude='./*.md' --exclude='.*' til-temp/ til-content
```

That excludes top-level markdown files and all dotfiles and dot-directories.

[source](https://www.digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories)

# Do Not Overwrite Existing Files

When using the `cp` command to copy files, you can use the `-n` flag to make
sure that you do not overwrite existing files.

h/t [Dillon Hafer](https://twitter.com/dillonhafer)

# Enable Multi-Select Of Results With fzf

You can pipe the output of any command to
[`fzf`](https://github.com/junegunn/fzf) and it will display it line-by-line in
a list that you can then fuzzy-find against.

By default you get to pick _one_ of those results. That result will go to
stdout, either printing to the terminal or being piped to the next command.

For some combinations of commands, it makes more sense to be able to select
_multiple_ results. `fzf` supports this with the `-m` (or `--multi`) flag.

```bash
$ ls | fzf -m | xargs cat
```

For instance, this series of commands pipes the output of `ls` (files and
directoris) to `fzf`. The `-m` flag means that you can hit `Tab` (or
`Shift+Tab`) to select multile entries. When you hit enter, each of the
selected entries will be executed one by one with `cat`.

I show a slightly more practical example of this in [Make One-Line Commands
Interactive with fzf](https://www.youtube.com/watch?v=wf5eXdwfVws).

See `man fzf` for more details.

# Exclude A Directory With Find

Using `find` is a handy way to track down files that meet certain criteria.
However, if there are directories full of irrelevant files, you may end up
with a lot of noise. What you want to do is exclude or ignore such
directories. For example, you probably don't want `find` to return results
from the `.git` directory of your project.

Specific directories can be excluded by combining the `-not` and `-path`
arguments.

For instance, to see all files modified within the last 10 days, but not
including anything in the `.git` directory, run the following:

```bash
$ find . -type f -not -path './.git/*' -ctime -10
```

[source](http://stackoverflow.com/questions/4210042/exclude-directory-from-find-command)

# Exclude Certain Files From An rsync Run

The `rsync` command can be used to copy files from one directory to another (as
well as to or from a remote system). It is generally used to broadly
synchronize all files in the source directory to a destination directory.

I recently ran into a situation where I wanted to recursively (`-a`) sync files
from a cloned git repository. I didn't want quite everything—namely dotfiles,
dot-directories (such as `.git/`), and top-level markdown files.

This is where the `--exclude` flag comes in to play.

The dotfiles and dot-directories can be excluded with the `.*` pattern.

```bash
$ rsync -anv --exclude='.*' dir1/ dir2
```

The top-level markdown files can be excluded, without excluding nested markdown
files, with the `./*.md` pattern.

```bash
$ rsync -anv --exclude='.*' --exclude='./.*md' dir1/ dir2
```

The `-n` and `-v` flags together provide a dry run of this with results that I
can check. Once I'm ready to do the real thing, I can remove those.

```bash
$ rsync -a --exclude='.*' --exclude='./.*md' dir1/ dir2
```

See `man rsync` for more details.

# Figure Out The Week Of The Year From The Terminal

Want to know what week of the year we are currently in? You can use the
[`date`](http://man7.org/linux/man-pages/man1/date.1.html) utility to figure it
out.

```bash
$ date +%V
```

The `%V` is a formatting directive with this description:

> ISO week number, with Monday as first day of week (01..53)

[source](https://stackoverflow.com/questions/3237882/get-week-of-year-from-day-of-year)

# File Type Info With File

Use the `file` utility to determine the type of a file:

```bash
$ file todo.md
todo.md: ASCII English text

$ file Hello.java
Hello.java: ASCII C++ program text

$ file Hello.class
Hello.class: compiled Java class data, version 52.0
```

The `Hello.java` file isn't exactly a C++ program, but close enough.

# Find A File Installed By Brew

I installed a homebrew formula to satisfy a dependency for a Rails application.
Related to [the whole mimemagic
debacle](https://github.com/rails/rails/issues/41750), I had run [`brew install
shared-mime-info`](https://formulae.brew.sh/formula/shared-mime-info). The
specific file that Rails needed from this install was `freedesktop.org.xml`.

It took me two commands to figure out if that file had been included and where
it was living.

The first was to find the _brew prefix directory_ — the place where homebrew
had installed everything related to `shared-mime-info`.

```bash
$ brew --prefix shared-mime-info
/usr/local/opt/shared-mime-info
```

Now that I know about that directory, I can use
[`fd`](https://github.com/sharkdp/fd)—a more user-friendly alternative to
`find`—to _find_ the specific file in that directory. Not wanting to cast too
narrow of a net, I decided to look for any `xml` file in that directory.

```bash
$ fd -e xml . /usr/local/opt/shared-mime-info
/usr/local/opt/shared-mime-info/share/shared-mime-info/packages/freedesktop.org.xml
```

The `-e` flag specifies the file extension. The `.` is the first argument, the
pattern to look for. In this case, anything. The second argument
(`/usr/local/opt/shared-mime-info`) is the path to look within. In this case,
the brew prefix for the `shared-mime-info` package.

# Find Files With fd

The [`fd` command](https://github.com/sharkdp/fd) is an open-source utility
written in Rust. It is a fast and user-friendly way to find files -- as
compared to the standard `find` command.

You can recursively look in the current directory for a file with `git` in
the name like so:

```bash
$ fd git
```

If you have a `.gitignore` file, it will ignore those files and directories
by default.

Providing a second argument, `fd` will start its recursive search from that
directory.

```bash
$ fd git ~
```

Here, `fd` will look for filenames with `git` everywhere within my home
directory.

You can `brew install fd` to get the command and `man fd` for more details.

# Find Newer Files

Use the `-newer` flag with the name of a file to find files that have a
newer modification date than the named file.

For instance,

```
$ find blog -name '*.md' -newer blog/first-post.md
```

will find all markdown files in the `blog` directory that have a
modification date more recent than `blog/first-post.md`.

# Fix Unlinked Node Binaries With asdf

You're using `asdf` to manage your version(s) of `node.js`. You have some
packages globally installed with `yarn` that are available as executable
binaries. When you install and switch to a new version of Node, those global
binaries no longer work.

Even uninstalling and re-installing those particular packages doesn't
necesarily fix it. That's because broken symlinks have been left behind.

`asdf` can help fix this with its `reshim` command:

```bash
$ asdf reshim <name> <version>
```

For instance, if you want to start using `14.4.0`, you can reshim like this:

```bash
$ asdf reshim nodejs 14.4.0
```

This will re-sync all the symlinks so that you are able to access and run those
binaries again.

# Forward Multiple Ports Over SSH

I sometimes find myself doing web app development on another machine via an SSH
connection. If I have the server running on port 3000, then I like to use
SSH's port forwarding feature so that I can access `localhost:3000` on my
physical machine.

```bash
$ ssh dev@server.com -L 3000:localhost:3000
```

What if I have two different servers running? I'd like to port forward both
of them -- that way I can access both.

SSH allows you to forward as many ports as you need. The trick is to specify
a `-L` for each.

```bash
$ ssh dev@server.com -L 3000:localhost:3000 -L 9009:localhost:9009
```

# Generate A SAML Key And Certificate Pair

The `openssl` utility can be used to generate a SAML (Security Assertion Markup
Language) key pair which consists of a public certificate and a private key.

```bash
openssl req -new -x509 -days 365 -nodes -sha256 \
  -out saml.crt \
  -keyout saml.key
```

> The req command primarily creates and processes certificate requests in
> PKCS#10 format. It can additionally create self-signed certificates, for use
> as root CAs, for example.

The flags to `req` are as follows:
- `-new` for a new certificate (cert) request
- `-x509` to output a self-signed cert instead of a cert request
- `-days 365` for a year-long cert
- `-nodes` to not encrypt the private key
- `-sha256` is the digest algorithm for signing the cert
- `-out saml.crt` specifies the certificate output file
- `-keyout saml.key` specifies the private key output file

See `man openssl` and search for `openssl req` for more details.

[source](https://www.lightsaml.com/LightSAML-Core/Cookbook/How-to-generate-key-pair/)

# Get Matching Filenames As Output From Grep

Standard use of the [`grep`
command](http://man7.org/linux/man-pages/man1/grep.1.html) outputs the lines
that match the specified pattern. You can instead output just the names of
the files where those matches occur. To do this, include the `-l` flag.

```bash
$ grep -Rl hashrocket .
./elixir/run-exunit-tests-in-a-deterministic-order.md
./git/show-file-diffs-when-viewing-git-log.md
./git/single-key-presses-in-interactive-mode.md
./internet/enable-keyboard-shortcuts-in-gmail.md
...
```

This recursive grep finds all the files where `hashrocket` appears. It only
looks for the first match in a file, so each file will only be listed once
even if there may have been multiple matches.

See `man grep` for more details.

# Get The Unix Timestamp

To get the Unix timestamp from your shell, use the `time` command with the
appropriate format:

```bash
$ date +%s
```

[source](http://stackoverflow.com/questions/1092631/get-current-time-in-seconds-since-the-epoch-on-linux-bash)

# Global Substitution On The Previous Command

Let's say we just executed the following command:

```bash
$ grep 'foo' foo.md
```

It gave us the information we were looking for and now we want to execute
a similar command to find the occurrences of `bar` in `bar.md`. The `^`
trick won't quite work here.

```bash
$ ^foo^bar<tab>
$ grep 'bar' foo.md
```

What we need is a global replace of `foo` in our previous command. The `!!`
command can help when we sprinkle in some `sed`-like syntax.

```bash
$ !!gs/foo/bar<tab>
$ grep 'bar' bar.md
```

For a short command like this, we haven't gained much. However, for large
commands that span the length of the terminal, this can definitely save us
a little trouble.

# Globbing For All Directories In Zsh

Globbing in Zsh is an expressive way to generate filenames for commands.
This includes working with directories. If I'd like to run a command against
all directories in the current directory, I can employ the `*(/)` globbing
pattern.

```bash
$ echo *(/)
one three two
```

What about all directories in the root directory?

```bash
$ echo /*(/)
/Applications /Library /Network /System /Users /Volumes /bin /cores /dev /home /net /opt /private /sbin /usr
```

You can go ahead and use that with any other command now (e.g. `ls`).

[source](http://zsh.sourceforge.net/Intro/intro_2.html)

# Globbing For Filenames In Zsh

Zsh has extensive support for _globbing_ for filenames. _Globbing_ is a
short-hand, of sorts, for generating filenames that meet certain criteria.
The generated filenames can be used with any command you might otherwise
provide a filename to in a unix setting.

For example, consider a directory full of files including many that are
named with numbers. You'd like to list all files that have numeric names.

Doing `ls` by itself gives the following result:

```bash
$ ls
10        11        2         3         4         801       92        code.rb   hello.txt
```

With the use of a numeric pattern, Zsh's _globbing_ helps `ls` limit the set
of listed files to just those with numeric names:

```bash
$ ls *[0-9]
10  11  2   3   4   801 92
```

This only scrapes the surface of what can be done with globbing in Zsh.

[source](http://zsh.sourceforge.net/Intro/intro_2.html)

h/t Josh Davey

# Grep For Files Without A Match

The `grep` command is generally used to find files whose contents match a
pattern. With the `-L` (`--files-without-match`) flag, `grep` can be used to
find files that don't match the given pattern.

For instance, to find files in the current directory that don't have
`foobar` anywhere in their content, run:

```bash
$ grep -L "foobar" ./*
```

[source](http://stackoverflow.com/questions/1748129/using-grep-to-find-files-that-dont-contain-a-given-string-pattern)

# Grep For Files With Multiple Matches

The `grep` utility is a great way to find files that contain a certain
pattern:

```bash
$ grep -r ".class-name" src/css/
```

This will recursively look through all the files in your css directory to
find matches of `.class-name`.

Often times these kinds of searches can turn up too many results and you'll
want to pare it back by providing some additional context.

For instance, we may only want results where `@media only screen` also
appears, but on a different line. To do this, we need to chain a series of
`greps` together.

```bash
$ grep -rl "@media only screen" src/css |
    xargs grep -l ".class-name"
```

This will produce a list of filenames (hence the `-l` flag) that contain
both a line with `@media only screen` and a line with `.class-name`.

If you need to, chain more `grep` commands on to narrow things down even
farther.

See `man grep` for more details.

# Grep For Multiple Patterns

You can use the `-e` flag with the `grep` command to search for a pattern.
Additionally, you can use multiple `-e` flags to search for multiple
patterns. For instance, if you want to search for occurrences of `ruby` and
`clojure` in a `README.md` file, use the following command:

```
$ grep -e ruby -e clojure README.md
```

See `man grep` for more details.

# Hexdump A Compiled File

The `hexdump` unix utility allows you to dump the contents of a
compiled/executable file in a _readable_ hexadecimal format. Adding the `-C`
flag includes a sidebar with a formatted version of that row of hexadecimal.

For example, a compiled _Hello World_ java program, `Hello.java`, will look
something like this:

```
> cat Hello.class | hexdump -C
00000000  ca fe ba be 00 00 00 34  00 1d 0a 00 06 00 0f 09  |.......4........|
00000010  00 10 00 11 08 00 12 0a  00 13 00 14 07 00 15 07  |................|
00000020  00 16 01 00 06 3c 69 6e  69 74 3e 01 00 03 28 29  |.....<init>...()|
00000030  56 01 00 04 43 6f 64 65  01 00 0f 4c 69 6e 65 4e  |V...Code...LineN|
00000040  75 6d 62 65 72 54 61 62  6c 65 01 00 04 6d 61 69  |umberTable...mai|
00000050  6e 01 00 16 28 5b 4c 6a  61 76 61 2f 6c 61 6e 67  |n...([Ljava/lang|
00000060  2f 53 74 72 69 6e 67 3b  29 56 01 00 0a 53 6f 75  |/String;)V...Sou|
00000070  72 63 65 46 69 6c 65 01  00 0a 48 65 6c 6c 6f 2e  |rceFile...Hello.|
00000080  6a 61 76 61 0c 00 07 00  08 07 00 17 0c 00 18 00  |java............|
00000090  19 01 00 0d 48 65 6c 6c  6f 2c 20 57 6f 72 6c 64  |....Hello, World|
000000a0  21 07 00 1a 0c 00 1b 00  1c 01 00 05 48 65 6c 6c  |!...........Hell|
000000b0  6f 01 00 10 6a 61 76 61  2f 6c 61 6e 67 2f 4f 62  |o...java/lang/Ob|
000000c0  6a 65 63 74 01 00 10 6a  61 76 61 2f 6c 61 6e 67  |ject...java/lang|
000000d0  2f 53 79 73 74 65 6d 01  00 03 6f 75 74 01 00 15  |/System...out...|
000000e0  4c 6a 61 76 61 2f 69 6f  2f 50 72 69 6e 74 53 74  |Ljava/io/PrintSt|
000000f0  72 65 61 6d 3b 01 00 13  6a 61 76 61 2f 69 6f 2f  |ream;...java/io/|
00000100  50 72 69 6e 74 53 74 72  65 61 6d 01 00 07 70 72  |PrintStream...pr|
00000110  69 6e 74 6c 6e 01 00 15  28 4c 6a 61 76 61 2f 6c  |intln...(Ljava/l|
00000120  61 6e 67 2f 53 74 72 69  6e 67 3b 29 56 00 20 00  |ang/String;)V. .|
00000130  05 00 06 00 00 00 00 00  02 00 00 00 07 00 08 00  |................|
00000140  01 00 09 00 00 00 1d 00  01 00 01 00 00 00 05 2a  |...............*|
00000150  b7 00 01 b1 00 00 00 01  00 0a 00 00 00 06 00 01  |................|
00000160  00 00 00 01 00 09 00 0b  00 0c 00 01 00 09 00 00  |................|
00000170  00 25 00 02 00 01 00 00  00 09 b2 00 02 12 03 b6  |.%..............|
00000180  00 04 b1 00 00 00 01 00  0a 00 00 00 0a 00 02 00  |................|
00000190  00 00 03 00 08 00 04 00  01 00 0d 00 00 00 02 00  |................|
000001a0  0e                                                |.|
000001a1
```

# Ignore The Alias When Running A Command

I have a number of shell aliases set up to override one command with another.
For instance, I want to run `bat` anytime I type `cat`, so I have `alias
cat=bat` in my shell configuration.

But what if I were to ever want to run `cat` instead of `bat`?

Aliases can be ignored several ways:

1. Precede the command with a backslash.

```bash
$ \cat
```

2. Wrap the command in quotes.

```bash
$ 'cat'
```

3. Pass the command to `command`.

```bash
$ command cat
```

[source](https://unix.stackexchange.com/questions/39291/run-a-command-that-is-shadowed-by-an-alias)

# Interactively Browse Available Node Versions

There are a variety of ways to install and manage your version(s) of Node. My
tool of choice is [`asdf`](https://github.com/asdf-vm/asdf).

Once I have the [Node.js asdf plugin](https://github.com/asdf-vm/asdf-nodejs)
installed, I can view the versions of Node that are available to install.

```bash
$ asdf list-all nodejs
```

This is a massive list. Normally my next step would be to `grep` against the
output. We can take it a step further by making the results interactively
browsable with [`FZF`](https://github.com/junegunn/fzf).

```bash
$ asdf list-all nodejs | fzf
```

I can type into the FZF prompt which will fuzzily narrow down the results. I
can even add a splash of regex to anchor agains the major version.

For instance, `10` will show `10.x.x` as well as pre-1.0 results that contain
`10`. If, however, I prompt FZF with `^10`, then the `10` is anchored to the
front of the string which is the major version -- so `10.x.x` results.

# Jump To The Ends Of Your Shell History

There are all sorts of ways to do things in your shell environment without
reaching for the arrow keys. For instance, if you want to move _up_ to the
previous command, you can hit `Ctrl-p`. To move _down_ to the next
command in your shell history, you can hit `Ctrl-n`.

But what if you want to move to the beginning and end of your entire shell
history?

Find your meta key (probably the one labeled `alt`) and hit `META-<` and
`META->` to move to the end and beginning of your shell history,
respectively.

[source](https://www.gnu.org/software/bash/manual/html_node/Commands-For-History.html)

# Kill Everything Running On A Certain Port

You can quickly kill everything running on a certain port with the following
command.

```bash
sudo kill `sudo lsof -t -i:3000`
```

This gets a list of pids for all the processes and then kills them.

[source](http://stackoverflow.com/questions/9346211/how-to-kill-a-process-on-a-port-on-ubuntu)

# Killing A Frozen SSH Session

Whenever an SSH session freezes, I usually mash the keyboard in desperation
and then kill the terminal session. This can be avoided though. SSH will
listen for the following kill command:

```
~.<cr>
```

This will kill the frozen SSH session and leave you in the terminal where
you were before you SSH'd.

source: [Jack C.](http://hashrocket.com/team/jack-christensen)

# Last Argument Of The Last Command

You can use `!$` as a way to reference the last argument in the last
command. This makes for an easy shortcut when you want to switch out
commands for the same long file name. For instance, if you just ran `cat` on
a file to see its contents

```bash
$ cat /Users/jbranchaud/.ssh/config
```

and now you want to edit that file. You can just pass `!$` to the `vim`
command:

```bash
$ vim !$
```

Hit enter or tab to get the full command:

```bash
$ vim /Users/jbranchaud/.ssh/config
```

h/t Dorian Karter

# Less With Style

I was using `less` the other day to look at a log file. The log file was
filled with ANSI color escape sequences which made it pretty painful to
read. I was stuck looking at a white, unparsed log file instead of a
colorful, stylish one.

The `-R` flag fixes this. It tells `less` to display the ANSI color escape
sequences as colors rather than the caret notation.

The tradeoff is that `less` has _less_ control over the overall display of
the screen. This may result in some buggy display behavior, but not
necessarily.

[source](http://superuser.com/questions/117841/get-colors-in-less-command)

# List All Users

On unix-based systems, all system users are listed with other relevant
information in the `/etc/passwd` file. You can output a quick list of the
users by name with the following command:

```
$ cut -d: -f1 /etc/passwd
```

[source](http://askubuntu.com/questions/410244/a-command-to-list-all-users-and-how-to-add-delete-modify-users)

# List Files Ordered By Modification Date

The `ls` command lists the files in a directory. Tacking on the `-l` flag
will list it in long format. By default, everything is listed in
lexicographical order. This is what `ls -l` looks like for this repository.

```
-rw-r--r--    1 jbranchaud  staff    628 Feb 14  2016 CONTRIBUTING.md
-rw-r--r--    1 jbranchaud  staff   1058 Feb 19  2015 LICENSE
-rw-r--r--    1 jbranchaud  staff  40983 Aug 18 16:59 README.md
drwxr-xr-x    5 jbranchaud  staff    170 Apr  1 14:45 ack
drwxr-xr-x    5 jbranchaud  staff    170 Feb 24 16:31 chrome
...
```

Sometimes you want a sense of what has been modified and when.
Lexicographical order isn't going to help much here. By tacking on the `-t`
flag, the files will be listed in order of their modification dates. Here is
`ls -lt` for the same repository.

```
-rw-r--r--    1 jbranchaud  staff  40983 Aug 18 16:59 README.md
drwxr-xr-x  119 jbranchaud  staff   4046 Aug 17 11:38 vim
drwxr-xr-x    5 jbranchaud  staff    170 Aug 16 10:47 internet
drwxr-xr-x   23 jbranchaud  staff    782 Aug  1 10:17 javascript
drwxr-xr-x    7 jbranchaud  staff    238 Jul 22 14:04 webpack
...
```

See `man ls` for more details.

# List Names Of Files With Matches

I often use `grep` and `ag` to search for patterns in a group or directory
of files. Generally I am interested in looking at the matching lines
themselves. However, sometimes I just want to know the set of files that
have matches. Both `grep` and `ag` can be told to output nothing more than
the names of the files with matches when given the `-l` flag.

This can come in particularly handy if you just want a list of files that
can be piped (or copied) for use with another command. This eliminates all
the extra noise.

h/t Dillon Hafer

# List Of Sessions To A Machine

The `last` command is a handy way to find out who has been connecting to a
machine and when.

> Last will list the sessions of specified users, ttys, and hosts, in
> reverse time order.  Each line of output contains the user name, the tty
> from which the session was conducted, any hostname, the start and stop
> times for the session, and the duration of the session.  If the session is
> still continuing or was cut short by a crash or shutdown, last will so
> indicate.

In particular, this can be useful for finding an IP address that you want to
connect to.

See `man last` for more details.

# List Parent pid With ps

The `ps` command, which stands for `process status`, is a great way to find
different processes running on a machine. Information like their `pid`
(_process id_) is included. If you are tracking down a process to kill and
find that that process is an unkillable zombie, then you may need to
simultaneously kill the process' parent as well.

So, you'll need the parent `pid` as well. You can get both the `pid` and the
parent `pid` of a process by including the `-f` flag with `ps`.

You may also want to include the `-e` flag to make sure that information
about other users' processes is included in the results.

# List Stats For A File

The `ls` command is good for listing files. Tacking on the `-la` flags gives
you a bunch of info about each of the listed files. To get even more info,
we can use the `stat` command.

```bash
$ stat README.md
16777220 143994676 -rw-r--r-- 1 jbranchaud staff 0 53557 "Jul 14 14:53:44 2018" "Jul 10 14:54:39 2018" "Jul 10 14:54:39 2018" "Jul 10 14:54:39 2018" 4096 112 0 README.md
```

That's definitely more info, but it is unlabeled and a lot to parse. We can
improve the output with the `-x` flag.

```bash
$ stat -x README.md
  File: "README.md"
  Size: 53557        FileType: Regular File
  Mode: (0644/-rw-r--r--)         Uid: (  501/jbranchaud)  Gid: (   20/   staff)
Device: 1,4   Inode: 143994676    Links: 1
Access: Sat Jul 14 14:53:44 2018
Modify: Tue Jul 10 14:54:39 2018
Change: Tue Jul 10 14:54:39 2018
```

See `man stat` for more details.

[source](https://www.unixtutorial.org/2008/11/how-to-update-atime-and-mtime-for-a-file-in-unix/)

# List The Available JDKs

Want to know what JDK versions are installed and available on your machine?
There is a command for that.

```bash
$ /usr/libexec/java_home -V
Matching Java Virtual Machines (3):
    9.0.4, x86_64:      "Java SE 9.0.4" /Library/Java/JavaVirtualMachines/jdk-9.0.4.jdk/Contents/Home
    1.8.0_162, x86_64:  "Java SE 8"     /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home
    1.8.0_161, x86_64:  "Java SE 8"     /Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home

/Library/Java/JavaVirtualMachines/jdk-9.0.4.jdk/Contents/Home
```

The listed VMs show what JDK versions you have and the final line shows
which is currently the default version.

# List The Stack Of Remembered Directories

When you open a new Unix shell, you start in some directory, probably your
home (`~/`) directory. If you use `pushd` to navigate to different
directories, there is a paper trail of your movements, a listing of where
you've been.  You can view this listing of directories with the `dirs`
command.

```
$ dirs
~/
$ pushd code
$ dirs
~/code ~/
$ pushd /usr/bin
$ dirs
/usr/bin ~/code ~/
```

Each time you `pushd`, the directory you have moved to is pushed onto the stack of
visited directories. Alternatively, you can use the `popd` command to return
to the previous directory, removing the current directory from the stack.

[source](http://www.gnu.org/software/bash/manual/html_node/Directory-Stack-Builtins.html#Directory-Stack-Builtins)

# Map A Domain To localhost

Do you want your computer to treat a domain as `localhost`? You can map it
as such in your `/etc/hosts` file. For example, if I have an web app that
refers to itself with the `dev.app.com` domain, I can add the following line
to my `/etc/hosts` file to make sure the domain resolves to `localhost`:

```
127.0.0.1 dev.app.com
```

Now, if I pop open my browser and visit `dev.app.com:3000`, I will see
whatever is being served to `localhost:3000`.

h/t Chris Erin

# Only Show The Matches

Tools like `grep`, `ack`, and `ag` make it easy to search for lines in a
file that contain certain text and patterns. They all come with the `-o`
flag which tells them to only show the part that matches.

This is particularly powerful when used with regex and piped into other
programs.

h/t Dillon Hafer

# Open The Current Command In An Editor

If you are working with a complicated command in the terminal trying to get
the arguments just right. Such as this `curl`:

```bash
curl https://api.stripe.com/v1/customers \
   -u sk_test_BQokikJOvBiI2HlWgH4olfQ2: \
   -d description="Customer for test@example.com" \
   -d source=tok_189fCz2eZvKYlo2CsGERUNIW
```

It can be tedious to move to and modify various parts of the command.
However, by hitting `Ctrl-x Ctrl-e`, the contents of the command buffer
will be opened into your default editor (i.e. `$EDITOR`). This will make
editing the command a bit easier. Saving and quitting the editor will put
the updated command in the command buffer, ready to run.

Hit `Ctrl-x Ctrl-e` with an empty command buffer if you want to start
crafting a command from scratch or if you are pasting one in from somewhere.

h/t Josh Davey

# Partial String Matching In Bash Scripts

To compare two strings in a bash script, you will have a snippet of code
similar to the following:

```bash
if [[ $(pwd) == "/path/to/current/directory" ]]
then
  echo "You are in that directory";
fi
```

You may only want to do a partial string match. For this, you can use the
`*` wildcard symbol.

```bash
if [[ $(pwd) == *"directory"* ]]
then
  echo "You are in that directory";
fi
```

[source](http://stackoverflow.com/questions/229551/string-contains-in-bash)

# PID Of The Current Shell

`$` expands to the process ID of the shell. So, you can see the PID of the
current shell with `echo $$`.

```bash
> echo $$
36609

> zsh

> echo $$
45431

> exit

> echo $$
36609
```

See the `Special Paramaters` section of `man bash` for more details.

[source](http://stackoverflow.com/questions/21063765/get-pid-in-shell-bash)

# Print A Range Of Lines For A File With Bat

I recently learned about a [faster and more colorful alternative to
cat](https://chireviewofbooks.com/2018/12/11/here-are-the-winners-of-the-2018-chicago-review-of-books-awards/)
-- [`bat`](https://github.com/sharkdp/bat). Like `cat`, the standard usage
is to print the entire contents of a file. You can instruct `bat` to only
print a range of lines from a file using the `--line-range` flag.

For instance the following command

```bash
$ bat --line-range=918:925 README.md
```

will produce the following output

![a range of lines from the README](https://i.imgur.com/MmKbNvl.png)

See `man bat` for more details.

# Print Out Files In Reverse

If you're familiar with `cat` -- the command you might use to print out a file
in the terminal -- then you may appreciate a similar command: `tac`.

With `tac` you can

> Write each FILE to standard output, last line first.

Notice that `tac` is `cat` spelled in reverse. That's what it does with your
files, prints them out in reverse.

Give it a try just as you'd use `cat`:

```bash
$ tac README.md
```

See `man tac` for more details.

# Provide A Fallback Value For Unset Parameter

If you are using a value in a parameter expansion expression that isn't set,
the result will be empty.

For instance, the XDG paths are not defined for me on OSX.

```bash
$ echo "${XDG_CONFIG_HOME}"

```

To make a script more robust, you can provide a fallback value (i.e. [default
value](https://wiki.bash-hackers.org/syntax/pe#use_a_default_value)). The
parameter expansion will use the fallback value if the primary value is either
unset or null.

The syntax for this is to follow the primary parameter with `:-` and then the
fallback parameter.

```bash
$ echo "${XDG_CONFIG_HOME:-$HOME/.local/share}"
/Users/jbranchaud/.local/share
```

Because I'm on OSX, this expands to my `$HOME` directory with `/.local/share`
appended.

[source](https://unix.stackexchange.com/a/122848/5916)

# Repeat Yourself

Use the `repeat` command to repeat some other command.

You can repeat a command any number of times like so

```
$ repeat 5 say Hello World
```

# Saying Yes

Tired of being prompted for confirmation by command-line utilities? Wish you
could blindly respond 'yes' to whatever it is they are bugging you about?
The `yes` command is what you've been looking for.

```
$ yes | rm -r ~/some/dir
```

This will respond `y` as `rm` asks for confirmation on removing each and
every file in that directory.

`yes` is just as good at saying *no*. Give it `no` as an argument and it
will happily (and endlessly) print `no`.

```
$ yes no
```

h/t [Chris Erin](https://twitter.com/MCNormalMode)

# Search Files Specific To A Language

The `ack` command makes it easy to narrow the set of searched files to those
of a specific programming language. For instance, if you have a rails
project and only want to search the ruby files, use the `--ruby` flag with
your `ack` command.

```bash
$ ack --ruby Active
```

With the `--ruby` flag, I get a manageable number of results. Without it,
not so much.

```bash
$ ack --ruby Active | wc -l
      26
$ ack Active | wc -l
    5253
```

See `man ack` for more details.

# Search History

Often times there is a very specific command you have entered into your bash
prompt that you need to run again. You don't want to have to type it again
and stepping manually through your history may be suboptimal if you typed it
quite a while ago. Fortunately, there is a simple history search feature
that you can use in this kind of situation.

Hit `Ctrl+r` and then start typing a moderately specific search term. Your
search history will be filtered by that term. Subsequent hitting of
`Ctrl+r` will step forward through that filtered history. Once you find the
command you are looking for, hit enter to execute it.

# Search Man Page Descriptions

You can use the `apropos` command with a keyword argument to search for that
words occurrence throughout all the man pages on your system. For instance,
invoking `apropos whatis` will bring up a list of entries including the
`apropos` command itself.

See `man apropos` for more details.

# Securely Remove Files

If you really want to make sure you have wiped a file from your hard drive,
you are going to want to use `srm` instead of `rm`. The man page for `srm`
gives the following description:

> srm  removes  each  specified file by overwriting, renaming, and truncating
> it before unlinking. This prevents other people from undeleting or
> recovering any information about the file from the command line.

h/t Dillon Hafer

# Set The asdf Package Version For A Single Shell

Generally when using [`asdf`](https://asdf-vm.com/), I set the global version
for a package/language to a good up-to-date default. And then I set `local`
versions for specific projects which get written to the `.tool-versions` file.

There is another option that `asdf` supports for when you want to use a version
without it being so _sticky_.

```bash
$ asdf shell postgres 12.3

$ psql --version
psql (PostgreSQL) 12.3

$ postgres --version
postgres (PostgreSQL) 12.3
```

With the
[`shell`](https://asdf-vm.com/#/core-manage-versions?id=set-current-version)
command, I tell `asdf` to shim the specified package version just for this
shell instance. If I switch back to another tab or open a new one, neither of
them will have been impacted by this shell-constrained setting.

This is handy for a one-off situation where you want to try something at a
specific version without impact the rest of your terminal session.

# Show A File Preview When Searching With FZF

[FZF](https://github.com/junegunn/fzf) by itself is a great way to fuzzy
find files. It gets even better when you can view a preview of a file before
opening it up. The `--preview` flag lets you do just this.

Add a basic file preview with `cat`:

```bash
$ fzf --preview 'cat {}'
```

The `{}` will get replaced a single-quoted string of the highlighted file.

You can spice up the preview a bit with color and line numbers using
[`bat`](https://github.com/sharkdp/bat):

```bash
$ fzf --preview 'bat --color "always" {}'
```

The `--color` flag tells `bat` to produce syntax highlighted output even
though it isn't in interactive mode.

Lastly, you can keep it performant by only showing the first 100 lines:

```bash
$ fzf --preview 'bat --color "always" --line-range 0:100 {}'
```

See `man fzf` for more details.

[source](https://github.com/dkarter/dotfiles/blob/master/vimrc#L362)

# Show Disk Usage For The Current Directory

The `du` utility can be used to show disk usage for a particular directory
or set of directories. When used without any arguments, it will show the
disk usage for the current directory.

```bash
$ du
80      ./.git/hooks
8       ./.git/info
256     ./.git/logs/refs/heads
...
```

with the `-h` command we can see it all in a human-readable format

```bash
$ du -h
 40K    ./.git/hooks
4.0K    ./.git/info
128K    ./.git/logs/refs/heads
```

and to get an even clearer picture we can pipe that through `sort -nr`

```bash
$ du -h | sort -nr
412K    ./vim
352K    ./postgres
340K    ./.git/logs
216K    ./.git/logs/refs
184K    ./ruby
156K    ./unix
148K    ./git
...
```

This sorts it numerically in reverse order putting the largest stuff at the
top.

# Show The Size Of Everything In A Directory

The `ls` command will list everything in a given directory.  The `du`
command is used to display disk usage statistics -- with the `-sh` flag, it
will display the file size in a human readable format.

We can combine these two commands with `xargs` to get a listing of the sizes
of everything in a directory.

```
ls | xargs du -sh
```

See `man du` and `man xargs` for more details.

# Skip Paging If Output Fits On Screen With Less

The `less` command can be used to display a file or the output of a command. It
is sometimes referred to as a pager because it paginates text that won't fit
onto a single screen.

```bash
$ ls | less
```

This will list the files for the current directory with `less`.

By default it will even display a small amount of text output within the pager.
If you want `less` to output text that fits onto a single screen directly to
the terminal, you can pass the `-F` and `-X` flags.

```bash
$ ls | less -FX
```

The `-F` flag tells `less` to exit if the output fits onto a single screen. The
`-X` tells `less` to skip screen clearing.

This is handy if you want the output of a command to show up in your shell
history.

See `man less` for more details.

# SSH Escape Sequences

In [Killing A Frozen SSH Session](killing-a-frozen-ssh-session.md), I talked
about an escape sequence for breaking out of an SSH session when the pipe
has been broken. This isn't the only SSH escape sequence though. To see the
others, hit `<Enter>~?`. This displays a help list with all the other escape
sequences.

```
> ~?
Supported escape sequences:
 ~.   - terminate connection (and any multiplexed sessions)
 ~B   - send a BREAK to the remote system
 ~C   - open a command line
 ~R   - request rekey
 ~V/v - decrease/increase verbosity (LogLevel)
 ~^Z  - suspend ssh
 ~#   - list forwarded connections
 ~&   - background ssh (when waiting for connections to terminate)
 ~?   - this message
 ~~   - send the escape character by typing it twice
(Note that escapes are only recognized immediately after newline.)
```

h/t Josh Davey

# SSH With Port Forwarding

Use the `-L` flag with `ssh` to forward a connection to a remote server

```
$ ssh someserver -L3000:localhost:3000
```

# Specify The Language For A File With Bat

The [`bat`](https://github.com/sharkdp/bat) utility is able to correctly
infer the language of most files it prints based on the file extension. In
some cases, you may want to specify a language other than the one it
guesses.

For instance, here is a React file printed with `bat`:

![bat with no CLI args](https://i.imgur.com/Jk0L6tB.png)

The `jsx` syntax doesn't look great because of the inferred language
highlighting doesn't account for it. We can get better results by telling
`bat` that the file should be parsed as `JavaScript (Babel)`.

![bat with language specified](https://i.imgur.com/yB1rYW4.png)

By including `--language=jsx` as a flag, `bat` uses a different language
parser and the output is now what I'm looking for.

# Sort In Numerical Order

By default, the `sort` command will sort things alphabetically. If you have
numerical input though, you may want a numerical sort. This is what the `-n`
flag is for.

If I have a directory of files with numbered names, sort doesn't quite do
the job by itself.

```bash
$ ls | sort
1.txt
10.txt
11.txt
12.txt
2.txt
3.txt
4.txt
5.txt
```

with the `-n` flag, I get the sort order I am looking for.

```bash
$ ls | sort -n
1.txt
2.txt
3.txt
4.txt
5.txt
10.txt
11.txt
12.txt
```

# Switch Versions of a Brew Formula

If you've installed a couple versions of a program via brew and you'd like
to switch from the currently linked version to the other installed version,
you can use the `switch` command. For instance, if you are on version
`1.8.2` of `phantomjs` and you'd like to switch to `1.9.0`, you can simply
invoke:

```
$ brew switch phantomjs 1.9.0
```

More generically:

```
$ brew switch <formula> <version>
```

# Touch Access And Modify Times Individually

When running the `touch` command on an existing file:

```bash
$ touch README.md
```

The `Access` and `Modify` times of that file will be updated to the current
time.

You can update these values individually with the `-a` and `-m` flags.

To update just the access time:

```bash
$ touch -a README.md
```

To update just the modify time:

```bash
$ touch -m README.md
```

See `man touch` for more details.

# Undo Some Command Line Editing

When using some of the fancy command line editing shortcuts, such as
`ctrl-u`, you may end up erroneously changing or deleting part of the
current command. Retyping it may be a pain or impossible if you've forgotten
exactly what was changed. Fortunately, bash's command line editing has undo
built in. Just hit `ctrl-_` a couple times to get back to where you want to
be.

h/t Chris Erin

[source](https://www.gnu.org/software/bash/manual/bashref.html#Command-Line-Editing)

# Update Package Versions Known By asdf Plugin

When you run `asdf list-all ruby`, asdf will list all the package versions it
knows about for that plugin. This list is based on when the plugin was most
recently installed or updated. If it has been a while, there are likely new
versions that asdf doesn't know about.

This list can be updated with the [`plugin-update`
command](https://asdf-vm.com/manage/plugins.html#update):

```bash
$ asdf update-plugin ruby
$ asdf plugin-update ruby
```

Now, the next time you run `asdf list-all ruby`, you'll have an up-to-date
listing of available package versions.

# Use fzf To Change Directories

When you install fzf (e.g. `brew install fzf`), you can also install
completions and a few keybindings by running the `/usr/local/opt/fzf/install`
binary.

Included with the keybindings is `Alt+c` which opens an fzf prompt for the
directories nested under your current directory. You can type into the prompt
to narrow down the results with fzf's fuzzy-finding capabilities. When you see
the directory you wan, you can use the arrows to navigate over it and then hit
end. You'll be `cd`'ed into that directory.

On my Mac, the `Alt` key is the `Option` key. Hitting `Opt+c` outputs the `ç`
character instead of opening this fzf prompt. It turns out, you can
alternatively hit `Esc+c` to trigger this prompt.

# Use Regex Pattern Matching With Grep

The `grep` command supports perl-flavored regular expression pattern matching.
Rather than grepping for specific words, you can use regex with grep to find
patterns throughout a text or command output.

As an example, I can list all Ruby versions available for install with
[`asdf`](https://github.com/asdf-vm/asdf) using the following command.

```bash
$ asdf list-all ruby
```

This produces a ton of lines of output including versions of `jruby` and
`truffleruby`.

I can use grep to filter this list down to the MRI versions which all start
with a digit (e.g. `2.6.5`).

```bash
$ asdf list-all ruby | grep "^[[:digit:]]"
```

That regex says, find all lines that begin (`^`) with a number (`[[:digit:]]`).
This means grep will filter down the output to things like `1.9.3-p551`,
`2.6.5`, and `2.7.0-preview2` whereas it will exclude `truffleruby-19.0.0` and
`jruby-9.2.9.0`.

[source](https://www.digitalocean.com/community/tutorials/using-grep-regular-expressions-to-search-for-text-patterns-in-linux)

# View A Web Page In The Terminal

There are a number of programs out there that allow you to view a web page
from right within the terminal. These text-based browsers are great for
viewing pages that make basic use of html without relying on JavaScript for
fancy user interactions, such as the docs page for a language.

One such program is `link`. If you don't already have it, you can install it
with something like `homebrew`. Then run `links` with any URL for a
magnificent, ad-free experience:

```
links http://www.postgresql.org/docs/current/static/functions-string.html
```

h/t Jack Christensen

# Watch The Difference

The `watch` command is a simple way to repeatedly run a particular command.
I'll sometimes use it to monitor the response from some endpoint. `watch`
can make monitoring responses even easier when the `-d` flag is employed.
This flag instructs `watch` to highlight the parts of the output that are
*different* from the previous run of the command.

So if I run

```
$ watch -d curl -LIs localhost:3000
```

I can easily see if the http status of the request changes.

# Watch This Run Repeatedly

I usually reach for a quick bash for loop when I want to run a particular
process a bunch of times in a row. The `watch` command is another way to
run a process repeatedly.

```
watch rspec spec/some/test.rb
```

The default is 2 seconds in between subsequent executions of the command.
The period can be changed with the `-n` flag though:

```
watch -n 2 rspec spec/some/test.rb
```

# Where Are The Binaries?

When I want to know where an executable is, I use `which` like so:

```
$ which rails
/Users/jbranchaud/.gem/ruby/2.1.4/bin/rails
```

That is the rails binary on my path that will be used if I enter a rails command.

However, with something like rails, there may be multiple versions on your
path. If you want to know where all of them are, you can use `where`, like
so:

```
$ where rails
/Users/jbranchaud/.gem/ruby/2.1.4/bin/rails
/Users/jbranchaud/.rubies/2.1.4/bin/rails
/usr/bin/rails
```

